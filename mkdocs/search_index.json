{
    "docs": [
        {
            "location": "/index.html", 
            "text": "Introduction\n\n\nmsm-lite: C++14 Meta State Machine Library\n\n\n\n\nYour scalable C++14 header only eUML-like meta state machine library with no dependencies\n\n\n\n\n\n\nUML\n\n\nUML2 Specification - State Machines\n\n\nBoost.MSM - UML Short Guide\n\n\nBoost.MSM - eUML\n\n\n\n\nWhy msm-lite?\n\n\n\n\nBoost.MSM - eUML is awesome, however it has a few huge limitations which stop it from being used it on a larger scale;\n  msm-lite, therefore, is trying to address those issues.\n\n\n\n\nProblems with Boost.MSM - eUML\n\n\n\n\nHorrible compilation times (see Benchmarks)\n\n\nProduces huge binaries (see Benchmarks)\n\n\nBased on too many macros\n\n\nHorrible and long error messages\n\n\nSometimes hard to follow as not all actions might be seen on transition table (ex. initial states, on_entry, on_exit)\n\n\nA lot of boilerplate code with actions/guards (requires fsm, event, source state, target state)\n\n\nData in states makes it harder share/encapsulate (UML compliant though)\n\n\nFunctional programming emulation (introduced before lambda expressions)\n\n\nHuge complexity may overwhelm in the beginning\n\n\nA lot of Boost dependencies\n\n\n\n\nmsm-lite design goals\n\n\n\n\n\n\nKeep the Boost.MSM - eUML goodies\n\n\n\n\nPerformance (see Benchmarks)\n\n\nMemory usage (see Benchmarks)\n\n\neUML DSL (s1 == s2 + event [ guard ] / action)\n\n\nUML standard compliant (As much as possible)\n\n\n\n\n\n\n\n\nEliminate Boost.MSM - eUML problems\n\n\n\n\nCompilation times (see Benchmarls)\n\n\nBinary size (see Benchmarks)\n\n\nReduce complexity by eliminating less used features\n\n\nShort and informative error messages (see Error Messages)\n\n\nLess boilerplate / no macros\n\n\nImprove visibility by having all actions on transition table\n\n\nNo dependencies / one header (1k lines)\n\n\nFunctional programming support using lamda expressions\n\n\n\n\n\n\n\n\nAdd a new functionality\n\n\n\n\n\n\nDependency injection support for guards/actions (see DI)\n\n\n\n\nLogging support (TBD)\n\n\nTesting support (TBD)\n\n\n\n\nWhat 'lite' implies?\n\n\n\n\nMinimal learning curve\n\n\nOnly crucial features\n\n\nGuaranteed performance and quick compilation times\n\n\nNo dependencies\n\n\n\n\nSupported features by msm-lite\n\n\n\n\nTransitions / internal transitions / anonymous transitions / no transition (see Example)\n\n\nGuards / actions (see Example)\n\n\nState entry / exit actions (see Example)\n\n\nOrthogonal regions (see Example)\n\n\nSub/Composite state machines (see Example)\n\n\nCustom flags (see Example)\n\n\nDispatcher (see Example)\n\n\nVisit current states (see Example)\n\n\nProposed boost.di integration (see Example)", 
            "title": "Home"
        }, 
        {
            "location": "/index.html#introduction", 
            "text": "msm-lite: C++14 Meta State Machine Library   Your scalable C++14 header only eUML-like meta state machine library with no dependencies    UML  UML2 Specification - State Machines  Boost.MSM - UML Short Guide  Boost.MSM - eUML   Why msm-lite?   Boost.MSM - eUML is awesome, however it has a few huge limitations which stop it from being used it on a larger scale;\n  msm-lite, therefore, is trying to address those issues.   Problems with Boost.MSM - eUML   Horrible compilation times (see Benchmarks)  Produces huge binaries (see Benchmarks)  Based on too many macros  Horrible and long error messages  Sometimes hard to follow as not all actions might be seen on transition table (ex. initial states, on_entry, on_exit)  A lot of boilerplate code with actions/guards (requires fsm, event, source state, target state)  Data in states makes it harder share/encapsulate (UML compliant though)  Functional programming emulation (introduced before lambda expressions)  Huge complexity may overwhelm in the beginning  A lot of Boost dependencies   msm-lite design goals    Keep the Boost.MSM - eUML goodies   Performance (see Benchmarks)  Memory usage (see Benchmarks)  eUML DSL (s1 == s2 + event [ guard ] / action)  UML standard compliant (As much as possible)     Eliminate Boost.MSM - eUML problems   Compilation times (see Benchmarls)  Binary size (see Benchmarks)  Reduce complexity by eliminating less used features  Short and informative error messages (see Error Messages)  Less boilerplate / no macros  Improve visibility by having all actions on transition table  No dependencies / one header (1k lines)  Functional programming support using lamda expressions     Add a new functionality    Dependency injection support for guards/actions (see DI)   Logging support (TBD)  Testing support (TBD)   What 'lite' implies?   Minimal learning curve  Only crucial features  Guaranteed performance and quick compilation times  No dependencies   Supported features by msm-lite   Transitions / internal transitions / anonymous transitions / no transition (see Example)  Guards / actions (see Example)  State entry / exit actions (see Example)  Orthogonal regions (see Example)  Sub/Composite state machines (see Example)  Custom flags (see Example)  Dispatcher (see Example)  Visit current states (see Example)  Proposed boost.di integration (see Example)", 
            "title": "Introduction"
        }, 
        {
            "location": "/overview/index.html", 
            "text": "Quick Start\n\n\n\n\nGet \nmsm.hpp\n header\n\n\n\n\n    wget https://raw.githubusercontent.com/krzysztof-jusiak/msm-lite/master/include/msm/msm.hpp\n\n\n\n\n\n\nInclude the header\n\n\n\n\n    #include \nboost/msm/msm.hpp\n\n\n\n\n\n\n\nCompile with C++14 support\n\n\n\n\n    $CXX -std=c++14 ...\n\n\n\n\nDependencies\n\n\nSupported/tested compilers\n\n\n\n\nClang-3.4+\n\n\nGCC-5.2+\n\n\n\n\nDesign\n\n\nPerformance\n\n\n\n\nSimple / 1'000'000 / clang++3.7 -O2 -s\n\n\n\n\n\n\n\n\n\n\n\n\nmsm-lite\n\n\nboost.msm-eUML\n\n\nboost.statechart\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n0.308s\n\n\n3.855s\n\n\n1.061s\n\n\n\n\n\n\nExecution time\n\n\n15ms\n\n\n17ms\n\n\n1232ms\n\n\n\n\n\n\nMemory usage\n\n\n14b\n\n\n32b\n\n\n200b\n\n\n\n\n\n\nExecutable size\n\n\n11K\n\n\n91K\n\n\n59K\n\n\n\n\n\n\n\n\n\n\nSimple / 1'000'000 / g++-6.0 -O2 -s\n\n\n\n\n\n\n\n\n\n\n\n\nmsm-lite\n\n\nboost.msm-eUML\n\n\nboost.statechart\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n0.407s\n\n\n7.879s\n\n\n1.790s\n\n\n\n\n\n\nExecution time\n\n\n16ms\n\n\n20ms\n\n\n929ms\n\n\n\n\n\n\nMemory usage\n\n\n14b\n\n\n32b\n\n\n224b\n\n\n\n\n\n\nExecutable size\n\n\n11K\n\n\n67K\n\n\n63K\n\n\n\n\n\n\n\n\n\n\nComposite / 1'000'000 / clang++3.7 -O2 -s\n\n\n\n\n\n\n\n\n\n\n\n\nmsm-lite\n\n\nboost.msm-eUML\n\n\nboost.statechart\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n0.360s\n\n\n4.526s\n\n\n1.293s\n\n\n\n\n\n\nExecution time\n\n\n12ms\n\n\n14ms\n\n\n491ms\n\n\n\n\n\n\nMemory usage\n\n\n20b\n\n\n60b\n\n\n200b\n\n\n\n\n\n\nExecutable size\n\n\n15K\n\n\n111K\n\n\n83K\n\n\n\n\n\n\n\n\n\n\nComposite / 1'000'000 / g++-6.0 -O2 -s\n\n\n\n\n\n\n\n\n\n\n\n\nmsm-lite\n\n\nboost.msm-eUML\n\n\nboost.statechart\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n0.475s\n\n\n9.363s\n\n\n2.037s\n\n\n\n\n\n\nExecution time\n\n\n9ms\n\n\n13ms\n\n\n404ms\n\n\n\n\n\n\nMemory usage\n\n\n20b\n\n\n60b\n\n\n224b\n\n\n\n\n\n\nExecutable size\n\n\n12K\n\n\n91K\n\n\n83K\n\n\n\n\n\n\n\n\n\n\nComplex / 1'000'000 / clang++3.7 -O2 -s\n\n\n\n\n\n\n\n\n\n\n\n\nmsm-lite\n\n\nboost.msm-eUML\n\n\nboost.statechart\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n0.813s\n\n\n1m15.935s\n\n\n3.661s\n\n\n\n\n\n\nExecution time\n\n\n71ms\n\n\n81ms\n\n\n6221ms\n\n\n\n\n\n\nMemory usage\n\n\n102b\n\n\n120b\n\n\n200b\n\n\n\n\n\n\nExecutable size\n\n\n35K\n\n\n611K\n\n\n343K\n\n\n\n\n\n\n\n\n\n\nComplex / 1'000'000 / g++-6.0 -O2 -s\n\n\n\n\n\n\n\n\n\n\n\n\nmsm-lite\n\n\nboost.msm-eUML\n\n\nboost.statechart\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n1.025s\n\n\n52.238s\n\n\n4.997s\n\n\n\n\n\n\nExecution time\n\n\n73ms\n\n\n77ms\n\n\n5520ms\n\n\n\n\n\n\nMemory usage\n\n\n102b\n\n\n120b\n\n\n224b\n\n\n\n\n\n\nExecutable size\n\n\n35K\n\n\n271K\n\n\n215K\n\n\n\n\n\n\n\n\n\n\nInclude / clang++3.7\n\n\n\n\n\n\n\n\n\n\n\n\nmsm-lite\n\n\nboost.msm-eUML\n\n\nboost.statechart\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n0.047s\n\n\n2.072s\n\n\n0.552s\n\n\n\n\n\n\n\n\n\n\nInclude / g++-6.0\n\n\n\n\n\n\n\n\n\n\n\n\nmsm-lite\n\n\nboost.msm-eUML\n\n\nboost.statechart\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n0.058s\n\n\n3.197s\n\n\n0.704s", 
            "title": "Overview"
        }, 
        {
            "location": "/tutorial/index.html", 
            "text": "", 
            "title": "Tutorial"
        }, 
        {
            "location": "/user_guide/index.html", 
            "text": "Documentation\n\n\n\n\nAPI reference\n\n\n\n\nnamespace msm {\n    template \nclass T\n // requires T to have T.configure()\n    class sm {\n    public:\n      using events; // list of supported events\n\n      template\nclass... TDeps\n // no requirements\n      explicit sm(TDeps\n...) noexcept; // action/guards dependencies\n      sm_impl(const sm \n) = delete;\n      sm_impl(sm \n) = default;\n\n      template \nclass TEvent\n // no requirements, returns whether event was handled or not\n      bool process_event(const TEvent \n) noexcept;\n\n      template \nclass TVisitor\n // requires TVisitor to be callable with auto\n      void visit_current_states(const TVisitor \n) const noexcept;\n\n      template \nclass TFlag\n // no requirements, returns whether active state has TFlag or not\n      bool is(const TFlag \n) const noexcept;\n    };\n\n    template \nclass... Ts\n // requires Ts to have Ts::src_state\n                           //                   , Ts::dst_state\n                           //                   , Ts::event\n                           //                   , Ts::deps\n                           //                   , Ts.execute(...)\n    auto make_transition_table(Ts...) noexcept;\n\n    action process_event;\n\n    template \nclass TEvent\n // no requirements\n    auto event{};\n\n    template \nclass T\n // no requirements\n    using state;\n\n    template \nclass T, T...\n\n    state\nT...\n operator\n_s(); // create a state, ex. \nidle\n_s\n\n    state initial;\n\n    template \nclass T\n // requires T to be callable and returns bool\n    auto operator!(const T \n) noexcept;\n\n    template \nclass T1, class T2\n // requires T1, T2 to be callable and returns bool\n    auto operator\n(const T1 \n, const T2 \n) noexcept;\n\n    template \nclass T1, class T2\n // requires T1, T2 to be callable and returns bool\n    auto operator||(const T1 \n, const T2 \n) noexcept;\n\n    template \nclass T1, class T2\n // requires T1, T2 to be callable\n    auto operator, (const T1 \nt1, const T2 \nt2) noexcept;\n}\n\n\n\n\n\n\n\n\nBoost.MSM - eUML Documentation\n\n\n\n\n\n\nBoost.MSM - eUML vs msm-lite\n\n\n\n\n\n\n// Boost.MSM - eUML\n\n#include \nboost/msm/back/state_machine.hpp\n\n#include \nboost/msm/front/state_machine_def.hpp\n\n#include \nboost/msm/front/euml/euml.hpp\n\n\nnamespace msm = boost::msm;\nnamespace mpl = boost::mpl;\nusing namespace boost::msm::front::euml;\n\nBOOST_MSM_EUML_EVENT(open_close)\n\nBOOST_MSM_EUML_ACTION(open_drawer){\n    template \nclass FSM, class EVT, class SourceState, class TargetState\n\n    void operator()(EVT const \n, FSM \n, SourceState \n, TargetState \n){}\n};\n\nBOOST_MSM_EUML_ACTION(close_drawer){\n    template \nclass FSM, class EVT, class SourceState, class TargetState\n\n    void operator()(EVT const \n, FSM \n, SourceState \n, TargetState \n){}\n};\n\nBOOST_MSM_EUML_STATE((), Empty)\nBOOST_MSM_EUML_STATE((), Open)\n\nBOOST_MSM_EUML_TRANSITION_TABLE(\n    (\n     Open == Empty + open_close / open_drawer,\n     Empty == Open + open_close / close_drawer\n    ), transition_table\n)\n\nBOOST_MSM_EUML_ACTION(Log_No_Transition){\n    template \nclass FSM, class Event\n void operator()(Event const \n, FSM \n, int state){}};\n\nBOOST_MSM_EUML_DECLARE_STATE_MACHINE((transition_table,                            // STT\n                                      init_ \n Empty,                              // Init State\n                                      no_action,                                   // Entry\n                                      no_action,                                   // Exit\n                                      attributes_ \n no_attributes_,               // Attributes\n                                      configure_ \n no_exception \n no_msg_queue,  // configuration\n                                      Log_No_Transition                            // no_transition handler\n                                      ),\n                                     player_)  // fsm name\n\nint main() {\n    msm::back::state_machine\nplayer_\n sm;\n    sm.process_event(open_close);\n    sm.process_event(open_close);\n}\n\n\n\n\n// msm-lite\n\n#include \nmsm/msm.hpp\n\n\nstruct open_close {};\n\nauto open_drawer = [] {};\nauto close_drawer = [] {};\n\nstruct player {\n  auto configure() const noexcept {\n    using namespace msm;\n    return make_transition_table(\n        \nEmpty\n_s(initial) == \nOpen\n_s + event\nopen_close\n / open_drawer,\n        \nOpen\n_s == \nEmpty\n_s + event\nopen_close\n / close_drawer\n    );\n  }\n};\n\nint main() {\n  msm::sm\nplayer\n player;\n  player.process_event(open_close{});\n  player.process_event(open_close{});\n}\n\n\n\n\n\n\n\n\nmsm-lite DSL\n\n\n\n\n\n\n\n\nExpression\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nsrc_state == dst_state + event\n [ guard \n (![]{return true;} \n guard2) ] / (action, action2, []{})\n\n\ntransition from src_state to dst_state on event e with guard and action\n\n\n\n\n\n\nsrc_state == dst_state + event\n [ guard ] / action\n\n\ntransition from src_state to dst_state on event e with guard and action\n\n\n\n\n\n\nsrc_state == dst_state / [] {}\n\n\nanonymous transition with action\n\n\n\n\n\n\nsrc_state == dst_state + event\n\n\ntransition on event e without guard or action\n\n\n\n\n\n\nstate + event\n [ guard ]\n\n\ninternal transition on event e when guard\n\n\n\n\n\n\n\n\n\n\n\n\nmsm-lite data dependencies\n\n\n\n\n\n\n                             /---- event\n                            |\nauto guard = [](double d, auto event) { return true; }\n                   |\n                   \\-------\\\n                           |\nauto action = [](int i){}  |\n                 |         |\n                 |         |\n            /---/  /------/\n           |      /\nsm\n...\n s{42, 87.0};\n\n\n\n\n\n* Configuration\n\n\nMacro                                   | Description\n----------------------------------------|-----------------------------------------\nMSM\\_POLICY\\_STATES\\_DST\\_SRC           | dst\\_state == src\\_state (same as in eUML)", 
            "title": "User Guide"
        }, 
        {
            "location": "/user_guide/index.html#documentation", 
            "text": "API reference   namespace msm {\n    template  class T  // requires T to have T.configure()\n    class sm {\n    public:\n      using events; // list of supported events\n\n      template class... TDeps  // no requirements\n      explicit sm(TDeps ...) noexcept; // action/guards dependencies\n      sm_impl(const sm  ) = delete;\n      sm_impl(sm  ) = default;\n\n      template  class TEvent  // no requirements, returns whether event was handled or not\n      bool process_event(const TEvent  ) noexcept;\n\n      template  class TVisitor  // requires TVisitor to be callable with auto\n      void visit_current_states(const TVisitor  ) const noexcept;\n\n      template  class TFlag  // no requirements, returns whether active state has TFlag or not\n      bool is(const TFlag  ) const noexcept;\n    };\n\n    template  class... Ts  // requires Ts to have Ts::src_state\n                           //                   , Ts::dst_state\n                           //                   , Ts::event\n                           //                   , Ts::deps\n                           //                   , Ts.execute(...)\n    auto make_transition_table(Ts...) noexcept;\n\n    action process_event;\n\n    template  class TEvent  // no requirements\n    auto event{};\n\n    template  class T  // no requirements\n    using state;\n\n    template  class T, T... \n    state T...  operator _s(); // create a state, ex.  idle _s\n\n    state initial;\n\n    template  class T  // requires T to be callable and returns bool\n    auto operator!(const T  ) noexcept;\n\n    template  class T1, class T2  // requires T1, T2 to be callable and returns bool\n    auto operator (const T1  , const T2  ) noexcept;\n\n    template  class T1, class T2  // requires T1, T2 to be callable and returns bool\n    auto operator||(const T1  , const T2  ) noexcept;\n\n    template  class T1, class T2  // requires T1, T2 to be callable\n    auto operator, (const T1  t1, const T2  t2) noexcept;\n}    Boost.MSM - eUML Documentation    Boost.MSM - eUML vs msm-lite    // Boost.MSM - eUML\n\n#include  boost/msm/back/state_machine.hpp \n#include  boost/msm/front/state_machine_def.hpp \n#include  boost/msm/front/euml/euml.hpp \n\nnamespace msm = boost::msm;\nnamespace mpl = boost::mpl;\nusing namespace boost::msm::front::euml;\n\nBOOST_MSM_EUML_EVENT(open_close)\n\nBOOST_MSM_EUML_ACTION(open_drawer){\n    template  class FSM, class EVT, class SourceState, class TargetState \n    void operator()(EVT const  , FSM  , SourceState  , TargetState  ){}\n};\n\nBOOST_MSM_EUML_ACTION(close_drawer){\n    template  class FSM, class EVT, class SourceState, class TargetState \n    void operator()(EVT const  , FSM  , SourceState  , TargetState  ){}\n};\n\nBOOST_MSM_EUML_STATE((), Empty)\nBOOST_MSM_EUML_STATE((), Open)\n\nBOOST_MSM_EUML_TRANSITION_TABLE(\n    (\n     Open == Empty + open_close / open_drawer,\n     Empty == Open + open_close / close_drawer\n    ), transition_table\n)\n\nBOOST_MSM_EUML_ACTION(Log_No_Transition){\n    template  class FSM, class Event  void operator()(Event const  , FSM  , int state){}};\n\nBOOST_MSM_EUML_DECLARE_STATE_MACHINE((transition_table,                            // STT\n                                      init_   Empty,                              // Init State\n                                      no_action,                                   // Entry\n                                      no_action,                                   // Exit\n                                      attributes_   no_attributes_,               // Attributes\n                                      configure_   no_exception   no_msg_queue,  // configuration\n                                      Log_No_Transition                            // no_transition handler\n                                      ),\n                                     player_)  // fsm name\n\nint main() {\n    msm::back::state_machine player_  sm;\n    sm.process_event(open_close);\n    sm.process_event(open_close);\n}  // msm-lite\n\n#include  msm/msm.hpp \n\nstruct open_close {};\n\nauto open_drawer = [] {};\nauto close_drawer = [] {};\n\nstruct player {\n  auto configure() const noexcept {\n    using namespace msm;\n    return make_transition_table(\n         Empty _s(initial) ==  Open _s + event open_close  / open_drawer,\n         Open _s ==  Empty _s + event open_close  / close_drawer\n    );\n  }\n};\n\nint main() {\n  msm::sm player  player;\n  player.process_event(open_close{});\n  player.process_event(open_close{});\n}    msm-lite DSL     Expression  Description      src_state == dst_state + event  [ guard   (![]{return true;}   guard2) ] / (action, action2, []{})  transition from src_state to dst_state on event e with guard and action    src_state == dst_state + event  [ guard ] / action  transition from src_state to dst_state on event e with guard and action    src_state == dst_state / [] {}  anonymous transition with action    src_state == dst_state + event  transition on event e without guard or action    state + event  [ guard ]  internal transition on event e when guard       msm-lite data dependencies                                 /---- event\n                            |\nauto guard = [](double d, auto event) { return true; }\n                   |\n                   \\-------\\\n                           |\nauto action = [](int i){}  |\n                 |         |\n                 |         |\n            /---/  /------/\n           |      /\nsm ...  s{42, 87.0};  \n* Configuration  Macro                                   | Description\n----------------------------------------|-----------------------------------------\nMSM\\_POLICY\\_STATES\\_DST\\_SRC           | dst\\_state == src\\_state (same as in eUML)", 
            "title": "Documentation"
        }, 
        {
            "location": "/examples/index.html", 
            "text": "Hello World\n\n\n\n\nTransitions\n\n\n\n\nAction Guards\n\n\n\n\nStates\n\n\n\n\nEvents\n\n\n\n\nOrthogonal Regions\n\n\n\n\nComposite\n\n\n\n\neUML Emulation\n\n\n\n\nDependency Injection\n\n\n\n\nDispatcher", 
            "title": "Examples"
        }, 
        {
            "location": "/CHANGELOG/index.html", 
            "text": "1.0.0\n - TBD\n\n\nAdded\n\n\n\n\nInitial version", 
            "title": "CHANGELOG"
        }, 
        {
            "location": "/CHANGELOG/index.html#100-tbd", 
            "text": "Added   Initial version", 
            "title": "1.0.0 - TBD"
        }, 
        {
            "location": "/TODO/index.html", 
            "text": "", 
            "title": "TODO"
        }
    ]
}