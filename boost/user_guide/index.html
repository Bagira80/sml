<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">

<meta name="author" content="Krzysztof Jusiak">
<link rel="canonical" href="http://boost-experimental.github.io/msm-lite/user_guide/index.html">
<title>User Guide - Boost.MSM-lite</title>

<link href="../css/boostbook.css" rel="stylesheet">
<link href="../css/github.css" rel="stylesheet">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">

<div width="100%">
<img alt="Boost C++ Libraries" width="277" height="86" src="../images/boost.png">
</div>

<hr>
<div class="spirit-nav">
<a accesskey="p"  href="../tutorial/index.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n"  href="../examples/index.html"><img src="../images/next.png" alt="Next"></a>
</div>

<div class="chapter">


<div class="toc">
<dl class="toc">

    
        <dt><span class="section"><a href="#transitional-concept">transitional [concept]</a></span></dt>
    

    
        <dt><span class="section"><a href="#configurable-concept">configurable [concept]</a></span></dt>
    

    
        <dt><span class="section"><a href="#callable-concept">callable [concept]</a></span></dt>
    

    
        <dt><span class="section"><a href="#dispatchable-concept">dispatchable [concept]</a></span></dt>
    

    
        <dt><span class="section"><a href="#state-core">state [core]</a></span></dt>
    

    
        <dt><span class="section"><a href="#event-core">event [core]</a></span></dt>
    

    
        <dt><span class="section"><a href="#make_transition_table-state-machine">make_transition_table [state machine]</a></span></dt>
    

    
        <dt><span class="section"><a href="#sm-state-machine">sm [state machine]</a></span></dt>
    

    
        <dt><span class="section"><a href="#testingsm-testing">testing::sm [testing]</a></span></dt>
    

    
        <dt><span class="section"><a href="#make_dispatch_table-utility">make_dispatch_table [utility]</a></span></dt>
    

    
        <dt><span class="section"><a href="#boost_msm_lite_log-debugging">BOOST_MSM_LITE_LOG [debugging]</a></span></dt>
    

</dl>
</div>



<div class="section">
<h3 id="transitional-concept">transitional [concept]</h3>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/msm-lite.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Requirements for transition.</p>
<p><strong><em>Synopsis</em></strong></p>
<pre><code>template &lt;class T&gt;
concept bool transitional() {
  return requires(T transition) {
    typename T::src_state;
    typename T::dst_state;
    typename T::event;
    typename T::deps;
    T::initial;
    T::history;
    { transition.execute() } -&gt; bool;
  }
}
</code></pre>
<p><strong><em>Semantics</em></strong></p>
<pre><code>transitional&lt;T&gt;
</code></pre>
<p><strong><em>Example</em></strong></p>
<pre><code>using namespace msm;

{
auto transition = ("idle"_s = X); // Postfix Notation
static_assert(transitional&lt;decltype(transition)&gt;::value);
}

{
auto transition = (X &lt;= "idle"_s); // Prefix Notation
static_assert(transitional&lt;decltype(transition)&gt;::value);
}
</code></pre>
<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/errors/not_transitional.cpp"> Transitional Example</a></li>
</ul>
<p>&nbsp;</p>
<hr />
<h3 id="configurable-concept">configurable [concept]</h3>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/msm-lite.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Requirements for the state machine.</p>
<p><strong><em>Synopsis</em></strong></p>
<pre><code>template &lt;class SM&gt;
concept bool configurable() {
  return requires(SM sm) {
    { sm.configure() };
  }
}
</code></pre>
<p><strong><em>Semantics</em></strong></p>
<pre><code>configurable&lt;SM&gt;
</code></pre>
<p><strong><em>Example</em></strong></p>
<pre><code>class example {
  auto configure() const noexcept {
    return make_transition_table();
  }
};

static_assert(configurable&lt;example&gt;::value);
</code></pre>
<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/errors/not_configurable.cpp"> Configurable Example</a></li>
</ul>
<p>&nbsp;</p>
<hr />
<h3 id="callable-concept">callable [concept]</h3>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/msm-lite.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Requirements for action and guards.</p>
<p><strong><em>Synopsis</em></strong></p>
<pre><code>template &lt;class TResult, class T&gt;
concept bool callable() {
  return requires(T object) {
    { object(...) } -&gt; TResult;
  }
}
</code></pre>
<p><strong><em>Semantics</em></strong></p>
<pre><code>callable&lt;SM&gt;
</code></pre>
<p><strong><em>Example</em></strong></p>
<pre><code>auto guard = [] { return true; };
auto action = [] { };

static_assert(callable&lt;bool, decltype(guard)&gt;::value);
static_assert(callable&lt;void, decltype(action)&gt;::value);
</code></pre>
<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/errors/not_callable.cpp"> Callable Example</a></li>
</ul>
<p>&nbsp;</p>
<hr />
<h3 id="dispatchable-concept">dispatchable [concept]</h3>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/msm-lite.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Requirements for the dispatch table.</p>
<p><strong><em>Synopsis</em></strong></p>
<pre><code>template &lt;class TDynamicEvent, TEvent&gt;
concept bool dispatchable() {
  return requires(T) {
    typename TEvent::id;
    { TEvent(declval&lt;TDynamicEvent&gt;()) };
  }
}
</code></pre>
<p><strong><em>Semantics</em></strong></p>
<pre><code>dispatchable&lt;SM&gt;
</code></pre>
<p><strong><em>Example</em></strong></p>
<pre><code>struct runtime_event { };

struct event1 {
  static constexpr auto id = 1;
};

struct event2 {
  static constexpr auto id = 2;
  explicit event2(const runtime_event&amp;) {}
};

static_assert(dispatchable&lt;runtime_event, event1&gt;::value);
static_assert(dispatchable&lt;runtime_event, event2&gt;::value);
</code></pre>
<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/errors/not_dispatchable.cpp"> Dispatchable Example</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/sdl2.cpp"> SDL2 Integration Example</a></li>
</ul>
<p>&nbsp;</p>
<hr />
<h3 id="state-core">state [core]</h3>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/msm-lite.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Represents a state machine state.</p>
<p><strong><em>Synopsis</em></strong></p>
<pre><code>template&lt;class TState&gt; // no requirements, TState may be a state machine
class state {
public:
  initial operator*() const noexcept; // no requirements

  template &lt;class T&gt; // no requirements
  auto operator&lt;=(const T &amp;) const noexcept;

  template &lt;class T&gt; // no requirements
  auto operator=(const T &amp;) const noexcept;

  template &lt;class T&gt; // no requirements
  auto operator+(const T &amp;) const noexcept;

  template &lt;class T&gt; requires callable&lt;bool, T&gt;
  auto operator[](const T) const noexcept;

  template &lt;class T&gt; requires callable&lt;void, T&gt;
  auto operator/(const T &amp;t) const noexcept;

  const char* c_str() noexcept;
};

template &lt;class T, T... Chrs&gt;
state&lt;unspecified&gt; operator""_s() noexcept;

// predefined states
state&lt;unspecified&gt; X;
</code></pre>
<p><strong><em>Requirements</em></strong></p>
<ul>
<li><a href="#callable-concept">callable</a></li>
</ul>
<p><strong><em>Semantics</em></strong></p>
<pre><code>state&lt;T&gt;{}
</code></pre>
<p><strong><em>Example</em></strong></p>
<pre><code>state&lt;class idle&gt; idle;
auto idle = state&lt;class idle&gt;{};
auto idle = "idle"_s;

auto initial_state = *idle;
auto history_state = idle(H);
auto terminate_state = X;
</code></pre>
<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/states.cpp"> States Example</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/composite.cpp"> Composite Example</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/orthogonal_regions.cpp"> Orthogonal Regions Example</a></li>
</ul>
<p>&nbsp;</p>
<hr />
<h3 id="event-core">event [core]</h3>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/msm-lite.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Represents a state machine event.</p>
<p><strong><em>Synopsis</em></strong></p>
<pre><code>template&lt;TEvent&gt; // no requirements
class event {
public:
  template &lt;class T&gt; requires callable&lt;bool, T&gt;
  auto operator[](const T &amp;) const noexcept;

  template &lt;class T&gt; requires callable&lt;void, T&gt;
  auto operator/(const T &amp;t) const noexcept;
};

template&lt;class TEvent&gt;
event&lt;TEvent&gt; event{};

// predefined events
auto on_entry = event&lt;unspecified&gt;;
auto on_exit = event&lt;unspecified&gt;;

template&lt;class TEvent&gt; unexpected_event{};
template&lt;class T&gt; exception{};
</code></pre>
<p><strong><em>Requirements</em></strong></p>
<ul>
<li><a href="#callable-concept">callable</a></li>
</ul>
<p><strong><em>Semantics</em></strong></p>
<pre><code>event&lt;T&gt;
</code></pre>
<p><strong><em>Example</em></strong></p>
<pre><code>auto my_int_event = event&lt;int&gt;;
</code></pre>
<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/action_guards.cpp"> Events Example</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/error_handling.cpp"> Error Handling Example</a></li>
</ul>
<p>&nbsp;</p>
<hr />
<h3 id="make_transition_table-state-machine">make_transition_table [state machine]</h3>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/msm-lite.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Creates a transition table.</p>
<p><strong><em>Synopsis</em></strong></p>
<pre><code>template &lt;class... Ts&gt; requires transitional&lt;Ts&gt;...
auto make_transition_table(Ts...) noexcept;
</code></pre>
<p><strong><em>Requirements</em></strong></p>
<ul>
<li><a href="#transitional-concept">transitional</a></li>
</ul>
<p><strong><em>Semantics</em></strong></p>
<pre><code>make_transition_table(transitions...);
</code></pre>
<p><strong><em>Example</em></strong></p>
<pre><code>auto transition_table_postfix_notation = make_transition_table(
  *"idle_s" + event&lt;int&gt; / [] {} = X
);

auto transition_table_prefix_notation = make_transition_table(
  X &lt;= *"idle_s" + event&lt;int&gt; / [] {}
);

class example {
public:
  auto configure() const noexcept {
    return make_transition_table();
  }
};
</code></pre>
<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/transitions.cpp"> Transition Table Example</a></li>
</ul>
<p>&nbsp;</p>
<hr />
<h3 id="sm-state-machine">sm [state machine]</h3>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/msm-lite.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Creates a State Machine.</p>
<p><strong><em>Synopsis</em></strong></p>
<pre><code>template&lt;class T&gt; requires configurable&lt;T&gt;
class sm {
public:
  using states = unspecified; // unique list of states
  using events = unspecified; // unique list of events which can be handled by the State Machine
  using transitions = unspecified; // list of transitions

  sm(sm &amp;&amp;) = default;
  sm(const sm &amp;) = delete;
  sm &amp;operator=(const sm &amp;) = delete;

  template &lt;class... TDeps&gt; requires is_base_of&lt;TDeps, dependencies&gt;...
  sm(TDeps&amp;&amp;...) noexcept;

  template&lt;class TEvent&gt; // no requirements
  bool process_event(const TEvent&amp;) noexcept(noexcept(T.configure()))

  template &lt;class TVisitor&gt; requires callable&lt;void, TVisitor&gt;
  void visit_current_states(const TVisitor &amp;) const noexcept(noexcept(visitor(state{})));

  template &lt;class TState&gt;
  bool is(const state&lt;TState&gt; &amp;) const noexcept;

  template &lt;class... TStates&gt; requires sizeof...(TStates) == number_of_initial_states
  bool is(const state&lt;TStates&gt; &amp;...) const noexcept;
};
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>TDeps...</code></td>
<td>is_base_of dependencies</td>
<td>constructor</td>
<td></td>
</tr>
<tr>
<td><code>process_event&lt;TEvent&gt;</code></td>
<td>-</td>
<td>process event <code>TEvent</code></td>
<td>returns true when handled, false otherwise</td>
</tr>
<tr>
<td><code>visit_current_states&lt;TVisitor&gt;</code></td>
<td><a href="#callable-concept">callable</a></td>
<td>visit current states</td>
<td>-</td>
</tr>
<tr>
<td><code>is&lt;TState&gt;</code></td>
<td>-</td>
<td>verify whether any of current states equals <code>TState</code></td>
<td>true when any current state matches <code>TState</code>, false otherwise</td>
</tr>
<tr>
<td><code>is&lt;TStates...&gt;</code></td>
<td>size of TStates... equals number of initial states</td>
<td>verify whether all current states match <code>TStates...</code></td>
<td>true when all states match <code>TState...</code>, false otherwise</td>
</tr>
</tbody>
</table>
<p><strong><em>Semantics</em></strong></p>
<pre><code>msm::sm&lt;T&gt;{...};
sm.process_event(TEvent{});
sm.visit_current_states([](auto state){});
sm.is(X);
sm.is(s1, s2);
</code></pre>
<p><strong><em>Example</em></strong></p>
<pre><code>struct my_event {};

class example {
public:
  auto configure() const noexcept {
  using namespace msm;
    return make_transition_table(
      *"idle"_s + event&lt;my_event&gt; / [](int i) { std::cout &lt;&lt; i &lt;&lt; std::endl; } = X
    );
  }
};

msm::sm&lt;example&gt; sm{42};
assert(sm.is("idle"_s));
assert(!sm.process_event(int{})); // no handled
assert(sm.process_event(my_event{})); // handled
assert(sm.is(X));

sm.visit_current_states([](auto state) { std::cout &lt;&lt; state.c_str() &lt;&lt; std::endl; });
</code></pre>
<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/hello_world.cpp"> Hello World Example</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/dependency_injection.cpp"> Dependency Injection Example</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/euml_emulation.cpp"> eUML Emulation Example</a></li>
</ul>
<p>&nbsp;</p>
<hr />
<h3 id="testingsm-testing">testing::sm [testing]</h3>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/msm-lite.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Creates a state machine with testing capabilities.</p>
<p><strong><em>Synopsis</em></strong></p>
<pre><code>namespace testing {
  template &lt;class T&gt;
  class sm : public msm::sm&lt;T&gt; {
   public:
    using msm::sm&lt;T&gt;::sm;

    template &lt;class... TStates&gt;
    void set_current_states(const detail::state&lt;TStates&gt; &amp;...) noexcept;
  };
}
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>set_current_states&lt;TStates...&gt;</code></td>
<td>-</td>
<td>set current states</td>
<td></td>
</tr>
</tbody>
</table>
<p><strong><em>Semantics</em></strong></p>
<pre><code>msm::testing::sm&lt;T&gt;{...};
sm.set_current_states("s1"_s);
</code></pre>
<p><strong><em>Example</em></strong></p>
<pre><code>msm::testing::sm&lt;T&gt;{inject_fake_data...};
sm.set_current_states("s1"_s);
sm.process_event(TEvent{});
sm.is(X);
</code></pre>
<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/testing.cpp"> Testing Example</a></li>
</ul>
<p>&nbsp;</p>
<hr />
<h3 id="make_dispatch_table-utility">make_dispatch_table [utility]</h3>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/msm-lite.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Creates a dispatch table to handle runtime events.</p>
<p><strong><em>Synopsis</em></strong></p>
<pre><code>template&lt;class TEvent, int EventRangeBegin, int EventRangeBegin, class SM&gt; requires dispatchable&lt;TEvent, typename SM::events&gt;
callable&lt;bool, (TEvent, int)&gt; make_dispatch_table(sm&lt;SM&gt;&amp;) noexcept;
</code></pre>
<p><strong><em>Requirements</em></strong></p>
<ul>
<li><a href="#dispatchable-concept">dispatchable</a></li>
</ul>
<p><strong><em>Semantics</em></strong></p>
<pre><code>make_dispatch_table&lt;T, 0, 10&gt;(sm);
</code></pre>
<p><strong><em>Example</em></strong></p>
<pre><code>struct runtime_event {
  int id = 0;
};
struct event1 {
  static constexpr auto id = 1;
  event1(const runtime_event &amp;) {}
};

auto dispatch_event = msm::make_dispatch_table&lt;runtime_event, 1 /*min*/, 5 /*max*/&gt;(sm);
assert(dispatch_event(event, event.id));
</code></pre>
<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/dispatch_table.cpp"> Dispatch Table Example</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/sdl2.cpp"> SDL2 Integration Example</a></li>
</ul>
<p>&nbsp;</p>
<hr />
<h3 id="boost_msm_lite_log-debugging">BOOST_MSM_LITE_LOG [debugging]</h3>
<p><strong><em>Header</em></strong></p>
<pre><code>#include &lt;boost/msm-lite.hpp&gt;
</code></pre>
<p><strong><em>Description</em></strong></p>
<p>Add logging support for the state machine.</p>
<p><strong><em>Synopsis</em></strong></p>
<pre><code>#define BOOST_MSM_LITE_LOG(T, SM, ...)
</code></pre>
<table>
<thead>
<tr>
<th>Expression</th>
<th>Requirement</th>
<th>Description</th>
<th>Returns</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>T</code></td>
<td>-</td>
<td>process_event/guard/action/state_change</td>
<td>Operation type</td>
</tr>
<tr>
<td><code>SM</code></td>
<td>-</td>
<td>-</td>
<td><a href="#sm-state-machine">state machine</a> type</td>
</tr>
<tr>
<td><code>...</code></td>
<td>-</td>
<td>process_event -&gt; (event)</td>
<td>log process event</td>
</tr>
<tr>
<td><code>...</code></td>
<td>-</td>
<td>guard -&gt; (guard, event, result)</td>
<td>log guard call</td>
</tr>
<tr>
<td><code>...</code></td>
<td>-</td>
<td>action -&gt; (action, event)</td>
<td>log action call</td>
</tr>
<tr>
<td><code>...</code></td>
<td>-</td>
<td>state_change -&gt; (src_state, dst_state)</td>
<td>log state change</td>
</tr>
</tbody>
</table>
<p><strong><em>Semantics</em></strong></p>
<pre><code>BOOST_MSM_LITE_LOG(state_change, sm&lt;example&gt;, current_state, new_state)
</code></pre>
<p><strong><em>Example</em></strong></p>
<pre><code>void log(const char* operation, ...) noexcept {
    printf("[%s]\n", operation);
}
#define BOOST_MSM_LITE_LOG(T, ...) log(#T)
#include "boost/msm-lite.hpp"

msm::sm&lt;example&gt; sm;
sm.process_event(event{}); // [process_event]
</code></pre>
<ul>
<li><a href="https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/logging.cpp"> Logging Example</a></li>
<li><a href="https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/plant_uml.cpp"> Plant UML Example</a></li>
</ul>
<p>&nbsp;</p>
<hr />
</div>

<script src="../js/highlight.pack.js"></script>

<script>
hljs.configure({languages:['cpp']});
hljs.initHighlightingOnLoad();
</script>

<div class="copyright-footer">Copyright &copy; 2016
      <p>Distributed under the Boost Software License, Version 1.0.
      (See accompanying file <code class="filename">LICENSE_1_0.txt</code> or copy at
      <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div>

</div>

<hr>
<div class="spirit-nav">
<a accesskey="p"  href="../tutorial/index.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n"  href="../examples/index.html"><img src="../images/next.png" alt="Next"></a>
</div>

<script async defer id="github-bjs" src="https://buttons.github.io/buttons.js"></script>
<select onChange="window.location.href=this.value" style="position: absolute; top: 20px; right: 30px; z-index: 10;">
    <option value="https://boost-experimental.github.io/msm-lite">Theme: Boost-Experimental</option>
    <option value="https://boost-experimental.github.io/msm-lite/boost" selected>Theme: Boost</option>
</select>
</body>
</html>