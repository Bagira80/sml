<!doctype html>
<html lang="en">

	<head>
		<meta charset="utf-8">

		<title>Experimental Boost.MSM-lite</title>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes">
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

		<link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/league.css" id="theme">

		<!-- Code syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>

	<body>

		<div class="reveal">
			<div class="slides">
          <section data-markdown=""
                   data-separator="^====+$"
                   data-separator-vertical="^----+$"
                   data-notes="^Note:">
					<script type="text/template">
C++Now 2016

# C++14 Meta State Machine Library

Kris Jusiak

==============================================================================

##UML State Machine

----

UML state machine, also known as UML statechart, is a significantly enhanced realization of the mathematical concept of a finite automaton in computer science applications as expressed in the Unified Modeling Language (UML) notation

----

![State Machine](images/state_machine.png)

----

##State Machine Concepts

----

A state machine is a concrete model describing the behavior of a system. It is composed of a finite number of states and transitions.

![State Machine](images/sm.gif)

----

A state has no sub states, can have data, entry and exit behaviors and deferred eve

![State](images/state.gif)

----

A transition is the switching between active states, triggered by an event. Actions and guard conditions can be attached to the transition.

![Transition](images/transition.jpg)

----

An initial state marks the first active state of a state machine. It has no real existence and neither has the transition originating from it.

![Initial State](images/init_state.gif)

----

The terminate pseudo state terminates the execution of a state machine.

![Teriminate State](images/terminate.gif)

----

A composite state is a state containing a region or decomposed in two or more regions.

----

A submachine is a state machine inserted as a state in another state machine. 

----

Orthogonal regions have its own set of mutually exclusive set of states and transitions.

![Composite](images/regions.gif)

==============================================================================

##Do I need a State Machine?

----

###State Machine design pattern allows you to AVOID maintaining following spaghetti code

----

```cpp
void some_function() {
  ...
  if ((is_running && !is_jumping) || just_started) {
      ...
  } else if (is_boss_level && extra_feature_enabled && !ab_test) {
      ...
  } else {
      ...
  }
}
```

----

TODO example

==============================================================================

##Experimental Boost.MSM-lite vs Boost.MSM-eUML vs Boost.Statechart

----

##Features

----

##UML features

----

* Transitions / Internal transitions / Anonymous transitions / No transition
* Actions / Guards
* State entry / exit actions
* Orthogonal regions
* Sub / Composite state machines
* History

----

##Other features

----

* Logging
* Testing
* Runtime Dispatcher
* Dependency Injection integration

----

##Benchmarks

----

###Environment

----

###2.3 GHz Intel Core i7 / 16 GB 1600 Mhz DDR3

----

| Test | CXXFLAGS | Events | States | Transitions | Process Events |
| ---- | -------- | ------ | ------ | ----------- | -------------- |
|[Simple Test](https://github.com/boost-experimental/msm-lite/tree/master/test/pt/simple) | -O2 -s | 6 | 5 | 12 | 1'000'000 |

----

| Clang-3.7        | Boost.MSM-lite | Boost.MSM-eUML | Boost.MSM3-eUML2 |Boost.Statechart |
|------------------|----------------|------------------|--------------------|-------------------|
| Compilation time | 0.144s         | 3.855s           | 8.699s             | 1.028s            |
| Execution time   | 15ms           | 17ms             | 17ms               | 1232ms            |
| Memory usage     | 14b            | 32b              | 28b                | 200b              |
| Executable size  | 11K            | 91K              | 15K + boost_system | 59K               |

----

| GCC-5.2          | Boost.MSM-lite | Boost.MSM-eUML | Boost.MSM3-eUML2 | Boost.Statechart |
|------------------|----------------|------------------|--------------------|-------------------|
| Compilation time | 0.175s         | 7.879s           | 17.101s            | 1.790s            |
| Execution time   | 15ms           | 19ms             | 21ms               | 929ms             |
| Memory usage     | 14b            | 32b              | 28b                | 224b              |
| Executable size  | 11K            | 67K              | 15K + boost_system | 63K               |

----

| Test | CXXFLAGS | Events | States | Transitions | Process Events |
| ---- | -------- | ------ | ------ | ----------- | -------------- |
|[Composite Test](https://github.com/boost-experimental/msm-lite/tree/master/test/pt/composite) | -O2 -s | 8 | 5 + 3 | 12 + 4 | 1'000 * 1'000 |

----

| Clang-3.7        | Boost.MSM-lite | Boost.MSM-eUML | Boost.MSM3-eUML2 | Boost.Statechart |
|------------------|----------------|------------------|--------------------|--------------------|
| Compilation time | 0.184s         | 4.526s           | 10.599s            | 1.293s             |
| Execution time   | 10ms           | 14ms             | 10ms               | 491ms              |
| Memory usage     | 20b            | 60b              | 52b                | 200b               |
| Executable size  | 15K            | 111K             | 15K + boost_system | 83K                |

----

| GCC-5.2          | Boost.MSM-lite | Boost.MSM-eUML | Boost.MSM3-eUML2 | Boost.Statechart |
|------------------|----------------|------------------|--------------------|--------------------|
| Compilation time | 0.248s         | 9.363s           | 23.404s            | 2.037s             |
| Execution time   | 9ms            | 13ms             | 12ms               | 404ms              |
| Memory usage     | 20b            | 60b              | 52b                | 224b               |
| Executable size  | 12K            | 91K              | 15K + boost_system | 83K                |

----

| Test | CXXFLAGS | Events | States | Transitions | Process Events |
| ---- | -------- | ------ | ------ | ----------- | -------------- |
|[Complex Test](https://github.com/boost-experimental/msm-lite/tree/master/test/pt/complex) | -O2 -s | 50 | 50 | 50 | 1'000'000 |

----

| Clang-3.7        | Boost.MSM-lite | Boost.MSM-eUML | Boost.MSM3-eUML2 | Boost.Statechart |
|------------------|----------------|------------------|--------------------|--------------------|
| Compilation time | 0.582s         | 1m15.935s        | 43.341s            | 3.661s             |
| Execution time   | 69ms           | 81ms             | 78ms               | 6221ms             |
| Memory usage     | 102b           | 120b             | 72b                | 200b               |
| Executable size  | 35K            | 611K             | 31K + boost_system | 343K               |

----

| GCC-5.2          | Boost.MSM-lite | Boost.MSM-eUML | Boost.MSM3-eUML2 | Boost.Statechart |
|------------------|----------------|------------------|--------------------|--------------------|
| Compilation time | 0.816s         | 52.238s          | 1m41.045s          | 4.997s             |
| Execution time   | 72ms           | 77ms             | 91ms               | 5520ms             |
| Memory usage     | 102b           | 120b             | 72b                | 224b               |
| Executable size  | 35K            | 271K             | 47K + boost_system | 215K               |


==============================================================================

##Experimental Boost.MSM-lite

==============================================================================

##Motivation

----

##[Boost.MSM - eUML](http://www.boost.org/doc/libs/1_60_0/libs/msm/doc/HTML/ch03s04.html) is awesome, but...

----

##Problems with Boost.MSM - eUML

----

###Long compilation times

----

###Huge binaries

----

###Long error messages

----

###Based on macros

----

###Functional programming emulation (C++03)

==============================================================================

##Overview

----

2016

---

Version C++14 - v1.0.0

---

https://github.com/boost-experimental/msm-lite

----

* One header (boost/msm-lite.hpp)
* 1.5k lines
* Neither Boost nor STL is required
* No 'virtual' methods
* No 'exceptions' (-fno-exceptions)

----

##Tested compilers

----

* [Clang-3.4+](https://travis-ci.org/boost-experimental/msm-lite)

* [GCC-5.2+](https://travis-ci.org/boost-experimental/msm-lite)

==============================================================================

##Design

----

##Goals

----

###Keep the Boost.MSM-eUML 'goodies'

----

###Design (front/back-end)

----

###Max performance

----

###Low memory usage

----

###eUML DSL

> `src_state + event [ guard ] / action -> dst_state`

----

###UML standard compliant (As much as possible)

----

##Eliminate Boost.MSM - eUML problems

----

###Speed up compilation times

* ####Up to 60x faster

----

###Reduce binary size

* ####3x smaller

----

###Better error messages

* ####Concepts emulation / no `MPL`

----

###Less boilerplate

* ####No macros

----

###Take advantage of modern C++ functional capabilities

* ####Lambdas as guards and actions

----

###Architecture

----

###Compile-time + run-time

---

> Generate jump table at compile-time
> and operates on it at run-time

----

##Front-end

----

###Responsible for providing an unified list of transitions

----

###DSL

> Domain Specific language

----

```cpp
"src_state"_s + event [ guard ] / action = "dst_state"_s
```

----

##Back-end

----

###Responsible for operating on transitions


==============================================================================

##User Guide

----

##Create events and states

----

An Event is just a unique type, which will be processed by the state machine.

```cpp
struct my_event { ... };
```

If you happen to have a Clang/GCC compiler, you can create an Event on the fly.

```cpp
using namespace msm;
auto event  = "event"_t;
```

-----

A State can have entry/exit behaviour executed whenever machine enters/leaves State and
represents current location of the state machine flow.

To create a state below snippet might be used.

```cpp
msm::state<class idle> idle;
// or
auto idle = msm::state<class idle>{};
```

If you happen to have a Clang/GCC compiler, you can create a State on the fly.

```cpp
using namespace msm;
auto state  = "idle"_s;
```

----

##Create guards and actions

----

Guards and actions are callable objects which will be executed by the state machine in order to verify whether a transition, followed by an action should take place.

----

Guard MUST return boolean value.

----

```cpp
auto guard1 = [] {
  return true;
};
```

----

```cpp
auto guard2 = [](int, double) {
  return true;
};
```

----

```cpp
auto guard3 = [](int, auto event, double) {
  return true;
};
```

----

Action MUST not return.

----

```cpp
auto action1 = [] { };
```

----

```cpp
auto action2 = [](int, double) { };
```

----

```cpp
auto action3 = [](int, auto event, double) { };
```

----

##Create a transition table

----

`msm-lite` is using eUML-like DSL in order to be as close as possible to UML design.

----

| Expression | Description |
|------------|-------------|
| state + event<e> [ guard ] | internal transition on event e when guard |
| src\_state / [] {} = dst\_state | anonymous transition with action |
| src\_state + event<e> = dst\_state | transition on event e without guard or action |

----

| Expression | Description |
|------------|-------------|
| src\_state + event<e> [ guard ] / action = dst\_state | transition from src\_state to dst\_state on event e with guard and action |
| src\_state + event<e> [ guard && (![]{return true;} && guard2) ] / (action, action2, []{}) = dst\_state | transition from src\_state to dst\_state on event e with guard and action |

----

Transition flow

----

```
src_state + event [ guard ] / action = dst_state
                                     ^
                                     |
                                     |
                                    1. src_state + on_exit
                                    2. dst_state + on_entry
```

----

```cpp
using namespace msm;

make_transition_table(...);
```

----

##Set initial states

----

Initial state tells the state machine where to start.

----

```cpp
using namespace msm;

make_transition_table(
 *"src_state"_s + event<my_event> [guard] / action = "dst_state"_s
, "dst_state"_s + event<game_over> = X
);
```

----

##Set initial states

----

Initial/Current state might be remembered by the State Machine so that whenever it will reentered
the last active state will reactivated.

----

```cpp
using namespace msm;
make_transition_table(
 "src_state"_s(H) + event<my_event> [guard]/ action = "dst_state"_s
,"dst_state"_s    + event<game_over>                 = X
);
```

----

You can have more than one initial state. All initial states will be executed in pseudo-parallel way
and are called orthogonal regions.

----

```cpp
using namespace msm;
make_transition_table(
 *"region_1"_s   + event<my_event1> [guard]/action = "dst_state1"_s
, "dst_state1"_s + event<game_over> = X,

 *"region_2"_s   + event<my_event2> [guard]/action = "dst_state2"_s
, "dst_state2"_s + event<game_over> = X
);
```

----

To create a state machine, we have to configure our transition table.

----

```cpp
class example {
public:
  auto configure() noexcept {
    using namespace msm;
    return make_transition_table(
     *"src"_s + event<my_event> [ guard ] / action = "dst"_s,
      "dst"_s + event<game_over> = X
    );
  }
};
```

----

```cpp
msm::sm<example> sm;
```

----

State machine constructor provides required dependencies for actions and guards.

----

```cpp
                            /-- event (injected from process_event)
                            |
auto guard = [](double d, auto event) { return true; }
                   |
                   \-------\
                           |
auto action = [](int i){}  |
                 |         |
                 |         |
                 \-\   /---/
                   |   |
msm::sm<exmple> s{42, 87.0};

// order in which parameters have to passed is not specificied
msm::sm<exmple> s{87.0, 42};
```

----

Or use experimental Boost.DI!

```cpp
auto injector = di::make_injector<example>();
```

----

State machine is a simple creature. Its main purpose is to process events.
In order to do it, `process_event` method might be used.

-----

```cpp
msm::sm<example> sm;

// returns true when handled
assert(sm.process_event(my_event{}));

// not handled by the state machine
assert(!sm.process_event(int{}));
```

----

##Dispatch events

----

`msm-lite` also provides a way to dispatch dynamically created events into the state machine.

----

```cpp
struct game_over {
  static constexpr auto id = SDL_QUIT;
  // explicit game_over(const SDL_Event&) noexcept;
};

auto dispatch_event =
  msm::make_dispatch_table<SDL_Event
                         , SDL_FIRSTEVENT
                         , SDL_LASTEVENT>(sm);

SDL_Event event{SDL_QUIT};

// will call sm.process(game_over{});
assert(dispatch_event(event, event.type));
```

----

##Handle errors - Unexpected Events

----

Different errors may occur when processing events. Firstly, event might not be handled (transition has not happened).
In such scenario `process_event` returns false and `unexpected_event` is fired.

----

```cpp
make_transition_table(
 *"src"_s + event<my_event> [ guard ] / action = "dst"_s
, "src"_s + unexpected_event<some_event> = X
);
```

----

##Exceptions

----

```cpp
make_transition_table(
 *"idle"_s + event<event> / []{throw std::runtime_error{"error"};}
 //--------------------------------------------------------------//
,*"error_handler"_s + exception<std::runtime_error> = X
, "error_handler"_s + exception<std::logic_error> = X
, "error_handler"_s + exception<> / [] { cleanup...; } = X
);
```

-----

##Test it

-----

Verify current state?

----

```cpp
msm::sm<example> sm;
assert(sm.process_event(my_event{}));

// is(X, s1, ...) when you have orthogonal regions
assert(sm.is(X));

//or

sm.visit_current_states([](auto state) {
  std::cout << state.c_str() << std::endl;
});
```

----

Verify transitions?

----

```cpp
testing::sm<example> sm{fake_data...};
// set_current_states("s3"_s, "s1"_s, ...) for orthogonal regions
sm.set_current_states("s3"_s);
assert(sm.process_event(event{}));
assert(sm.is(X));
```

----

##Debug it

----

`msm-lite` provides logging capabilities in order to inspect state machine flow.
To enable logging you have to define `BOOST_MSM_LITE_LOG`.

----

```cpp
template <class SM, class TEvent>
void log_process_event(const TEvent&) {
  printf("[%s][process_event] %s\n", typeid(SM).name()
                                   , typeid(TEvent).name());
}
```

----

```cpp
template <class SM, class TAction, class TEvent>
void log_guard(const TAction&, const TEvent&, bool result) {
  printf("[%s][guard] %s %s %s\n", typeid(SM).name()
                                 , typeid(TAction).name()
                                 , typeid(TEvent).name()
                                 , (result ? "[OK]" : "[Reject]"));
}
```

----

##Debug it

----

```cpp
template <class SM, class TAction, class TEvent>
void log_action(const TAction&, const TEvent&) {
  printf("[%s][action] %s %s\n", typeid(SM).name()
                               , typeid(TAction).name()
                               , typeid(TEvent).name());
}
```

----

```cpp
template <class SM, class TSrcState, class TDstState>
void log_state_change(const TSrcState& src, const TDstState& dst) {
  printf("[%s][transition] %s -> %s\n", typeid(SM).name()
                                      , src.c_str()
                                      , dst.c_str());
}
```

==============================================================================

##Implementation

----

###Transition

> Glue between Front-end and Back-end

----

```cpp
template <class TSrcState
        , class TDstState
        , class TEvent = anonymous
        , class TGuard = always
        , class TAction = none>
struct transition {
  template <class TDeps>
  constexpr auto execute(TDeps &, TEvent &);

  TGuard guard;
  TAction action;
};
```

----

##Front-end

----

###DSL (Domain Specific language)

> `src_state + event [ guard ] / action -> dst_state`

----

###State

----

```
template <class TState>
struct state {
  template <class T>
  auto operator=(const T &t) const { return transition<T, state>{}; }

  template <class T>
  auto operator<=(const T &t) const { return transition<TState, T>{}; }

  template <class T>
  auto operator+(const T &t) const { return transition<TState, T>{}; }

  template <class T> requires callable<bool, T>()
  auto operator[](const T &t) const { return transition<TState, T>{}; }

  template <class T> requires callable<void, T>()
  auto operator/(const T &t) const { return transition<TState, T>{}; }
};
```

----

###Event

----

```cpp
template <class>
struct event {
  template <class T> requires callable<bool, T>()
  auto operator[](const T &t) const { return transition<event, T>{}; }

  template <class T> requires callable<void, T>()
  auto operator/(const T &t) const { return transition<event, T>{}; }
};
```

----

###Guards

----

###Operators

> `and_, or_, not_`

----

```cpp
template <class... Ts>
struct and_ {
  template <class TEvent, class TDeps>
  auto operator()(const TEvent &event, TDeps &deps) {
    return invoke(std::get<Ns-1>(args), event, deps) && ...;
  }

  std::tuple<Ts...> args;
};
```

----

... for `or_` and `not_`

----

###User-defined operators

> `namespace msm`

----

```cpp
template <class T> requires callable<bool, T>()
auto operator!(T&& t) {
  return not_<T>(std::forward<T>(t));
}
```

----

```cpp
template <class T1, class T2> 
  requires callable<bool, T1>() && callable<bool, T2>()
auto operator&&(T1&& t1, T2&& t2)  {
  return and_<T1, T2>(std::forward<T1>(t1), std::forward<T2>(t2));
}
```

----

```cpp
template <class T1, class T2> 
  requires callable<bool, T1>() && callable<bool, T2>()
auto operator||(T1&& t1, T2&& t2) {
  return or_<T1, T2>(std::forward<T1>(t1), std::forward<T2>(t2));
}
```

----

###Example

----

```cpp
auto true_ = [] { return true; };
auto false_ = [] { return false_; };

auto guards = (!true_ || (true_ && false_ || ![]{ return false; }));
              // not_<or_<and_<false_, not_<[]{return false;}>>>>
```

----

###Actions

----

###User-defined operators

> `namespace msm`

----

```cpp
template <class T1, class T2> 
  requires callable<void, T1>() && callable<void, T2>()
auto operator,(T1&& t1, T2&& t2) {
  return seq_<T1, T2>(std::forward<T1>(t1), std::forward<T2>(t2));
}
```

----

###Example

----

```cpp
auto action = [] { };

auto actions = (action, action, []{}, action); 
               // seq_<action, action, []{}, action>
```

----

###Brining it all together

----

```cpp
template <class... Ts> requires transitional<Ts>()...
auto make_transition_table(Ts&&... ts) {
  return std::tuple<Ts...>{std::forward<Ts>(ts)...};
}
```

----

###Example

----

```cpp
make_transition_table(
  state<class Idle> + play [ is_playing ] = state<class Wait>
  state<class Idle> + play [ !is_playing ] / play_song = state<class Play>
  state<class Play> + stop / (stop_song, reset_song) = state<class Idle>
);
```

----

```cpp
std::tuple<
  transition<Idle, Wait, Play, is_playing>
, transition<Idle, Wait, Play, not_<is_playing>, play_song>
, transition<Play, Idle, Stop, always, seq_<stop_song
                                          , reset_song>, play_song>
>
```

----

###Back-end

----

###Operates on transitions

----

###How to get maximum run-time performance?

----

###Generated dispatch (jump) table

----

```cpp
void (*dispatch_table[])(TEvent&&) = {
  HandleTEventInState1
, HandleTEventInState2
, ...
, HandleTEventInStateN
};
```

```cpp
template<class TEvent>
void process_event(TEvent&& event) {
  dispatch_table[current_state](std::forward<TEvent>(event));
}
```

----

TODO assembler

----

###How to get quick compilation times?

----

##Always measure!

----

##Approach

----

###Pre-process transitions

  * ####Avoid doing to much per event

----

###Meta-programing utilities

----

```cpp
template <class...> struct type {};
template <class, class> struct pair {};
template <class...> struct type_list { using type = type_list; };
template <class... Ts> struct inherit : Ts... { using type = inherit; };
struct none_type {};

template <template <class...> class, class>
struct apply;
template <template <class...> class T
        , template <class...> class U, class... Ts>
struct apply<T, U<Ts...>> {
  using type = T<Ts...>;
};
template <template <class...> class T, class D>
using apply_t = typename apply<T, D>::type;

```

----

###Map / at

----

```cpp
template <class... Ts> struct map : Ts... {};

template <class T> struct no_decay { using type = T; };
template <class TDefault, class> static no_decay<TDefault> lookup(...);

template <class, class TKey, class TValue>
static no_decay<TValue> lookup(pair<TKey, TValue> *);

template <class TDefault, class TKey, class T>
using at_key = decltype(lookup<TDefault, TKey>((T *)0));

template <class T, class TKey, class TDefault = void>
using at_key_t = typename at_key<TDefault, TKey, T>::type;
```

----

###Boost.Hana vs Boost.MPL vs ...

----

```cpp
constexpr auto m = 
  hana::make_map(hana::make_pair(event, transitions), ...);
static_assert(m[event] == transitions);
```

```cpp
using m = 
  mpl::map<mpl::pair<event, transitions>...>;
static_assert(boost::is_same<mpl::at<m, event>::type, transitions>{});
```

```cpp
using m = 
  map<pair<event, transitions...>>;
static_assert(boost::is_same<at_key_t<m, event>, transitions>{});
```

----

| Number of elements | Map     | Boost.Hana | Boost.MPL |
| ------------------ | ------- | ---------- | --------- |
| 128                | 0.076s  | 1.186s   | 1.453s  |

----

###Unique

----

```cpp
template <class...> struct unique;

template <class... Rs, class T, class... Ts>
struct unique<type<Rs...>, T, Ts...> : std::conditional_t<
  std::is_base_of<type<T>, inherit<type<Rs>...>>{},
  unique<type<Rs...>, Ts...>,
  unique<type<Rs..., T>, Ts...>
> {};

template <class... Rs> struct unique<type<Rs...>>
  : type_list<Rs...>
{};

template <class... Ts> using unique_t =
  typename unique<type<>, Ts...>::type;
```

----

###Boost.Hana vs Boost.MPL vs ...

----

```cpp
using u = decltype(
  hana::unique(hana::sort(hana::make_tuple(event1, event2, event1)))
);
static_assert(make_tuple(event1, event2) == u);
```

```cpp
using u = typename mpl::unique<
  typename mpl::sort<
    mpl::vector<event1, event2, event1>
  , boost::is_same<mpl::_1, mpl::_2>
  >::type;
>;
static_assert(std::is_same<u, mpl::vector<event1, event2>>{});
```

```cpp
using u = unique_t<event1, event2, event1>;
static_assert(std::is_same<u, type_list<event1, event2>>{});
```

----

| Number of elements | unique    | Boost.Hana | Boost.MPL |
| ------------------ | --------- | ---------- | --------- |
| 128                | 0.085s  | 7.821s   | 10.409s |

----

###From front-end

----

```cpp
std::tuple<
  transition<Idle, Wait, Play, is_playing>
, transition<Idle, Wait, Play, not_<is_playing>, play_song>
, transition<Play, Idle, Stop, always, seq_<stop_song
                                          , reset_song>, play_song>
>
```

----

```cpp
mappings_t = {
  e2 {
    string<'i', 'd', 'l', 'e'> {
      transition<state<string<'s', '2'> >, state<string<'i', 'd', 'l', 'e'> >, event<e2>, always, none>
    }
  },

  e1 {
    string<'i', 'd', 'l', 'e'> {
      transition<state<string<'s', '1'> >, state<string<'i', 'd', 'l', 'e'> (initial_state)>, event<e1>, always, none> >
    }
  }
}
```

----

using states_ids_t = aux::apply_t<aux::type_id, states_t>;

template <int, class T>
struct type_id_type {};
template <class, class...>
struct type_id_impl;
template <int... Ns, class... Ts>
struct type_id_impl<index_sequence<Ns...>, Ts...> : type_id_type<Ns, Ts>... {};
template <class... Ts>
struct type_id : type_id_impl<make_index_sequence<sizeof...(Ts)>, Ts...> {};

template <class T, int, int N>
constexpr auto get_id_impl(type_id_type<N, T> *) {
  return N;
}
template <class T, int D>
constexpr auto get_id_impl(...)  {
  return D;
}
template <class TIds, int D, class T>
constexpr auto get_id()  {
  return get_id_impl<T, D>((TIds *)0);
}


----


###Combine in with our case

----

```cpp
using event_transitions = map<
    pair<
      event1,
    , type_list<
        map<pair<state1, type_list<transition1...>>>
       , map<pair<state2, type_list<transition2...>>>
      >
    >
  , pair<
      event2,
    , type_list<
        map<pair<state2, type_list<transition2...>>>
       , map<pair<state3, type_list<transition3...>>>
      >
    >
>;
```

```cpp
static_assert(at_key_t<event_transitions, event1> ==
    , type_list<
        map<pair<state1, type_list<transition1...>>>
       , map<pair<state2, type_list<transition2...>>>
      >
);
```

==============================================================================

##Examples

----

[Hello World](https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example#hello-world)

[Events](https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example#events) |
[States](https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example#states) |
[Actions Guards](https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example#actions-guards) |
[Transitions](https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example#transitions)

[Orthogonal Regions](https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example#orthogonal-regions) |
[Composite](https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example#composite) |
[History](https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example#history)

[Error handling](https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example#error-handling) |
[Logging](https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example#logging) |
[Testing](https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example#testing)

[Runtime Dispatcher](https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example#runtime-dispatcher) |
[eUML Emulation](https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example#euml-emulation) |
[Dependency Injection](https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example#dependency-injection)

[SDL2 Integration](https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example#sdl2-integration) |
[Plant UML Integration](https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example#plant-uml-integration)

==============================================================================

##Questions?

* Documentation
    * http://boost-experimental.github.io/msm-lite

* Source Code
    * https://github.com/boost-experimental/msm-lite

* Try it online
    * http://boost-experimental.github.io/msm-lite/examples
					</script>

				</section>

			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>

			// Full list of configuration options available at:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({

        // Display controls in the bottom right corner
        controls: true,

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Vertical centering of slides
        center: true,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // Turns fragments on and off globally
        fragments: false,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Enable slide navigation via mouse wheel
        mouseWheel: true,

        // Hides the address bar on mobile devices
        hideAddressBar: true,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style
        transition: 'slide', // none/fade/slide/convex/concave/zoom

        // Transition speed
        transitionSpeed: 'default', // default/fast/slow

        // Transition style for full page slide backgrounds
        backgroundTransition: 'default', // none/fade/slide/convex/concave/zoom

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Parallax background image
        parallaxBackgroundImage: '', // e.g. "'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg'"

        // Parallax background size
        parallaxBackgroundSize: '', // CSS syntax, e.g. "2100px 900px"

        // Number of pixels to move the parallax background per slide
        // - Calculated automatically unless specified
        // - Set to 0 to disable movement along an axis
        parallaxBackgroundHorizontal: null,
        parallaxBackgroundVertical: null,

				// Optional reveal.js plugins
				dependencies: [
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
					{ src: 'plugin/zoom-js/zoom.js', async: true },
					{ src: 'plugin/notes/notes.js', async: true }
				]
			});

		</script>

	</body>
</html>
