{
    "docs": [
        {
            "location": "/index.html", 
            "text": "Introduction\n\n\n\n\n\n\n\n\nExperimental Boost.MSM-lite\n\n\n\n\n\n\n\n\n\n\n\n\nYour scalable C++14 header only eUML-like Meta State Machine library with no dependencies (\nTry it online!\n)\n\n\nGitHub\n\n\n\n\n\n\n\n\n\n\n Latest Release: \nv1.0.1\n (May 6, 2016)\n\n\n \nDownload\n \n \n \nChangelog\n \n \n \nTutorial\n \n \n \nExamples\n\n\n\n\n\nUML State Machine\n\n\n\n\nState Machine\n\n\nUML2 Specification\n\n\nBoost.MSM - eUML\n\n\n\n\nDo I need a State Machine?\n\n\nState Machine design pattern prevents you from creating and maintaining spaghetti code.\n\n\nvoid some_function() {\n    ...\n    if ((is_running \n !is_jumping) || just_started) {\n        ...\n    } else if (is_boss_level \n extra_feature_enabled \n !ab_test) {\n        ...\n    } else {\n        ...\n    }\n}\n\n\n\n\nIf above code looks somewhat similar to your code base or if you like\nto avoid it \nBoost.MSM-lite\n may suit you!\n\n\nReal Life examples?\n\n\n\n\n SDL2 Integration Example\n\n\n Plant UML Example\n\n\n Logging Example\n\n\n Testing Example\n\n\n\n\n\n\nWhy Boost.MSM-lite?\n\n\n\n\nBoost.MSM - eUML\n is awesome, however it has a few huge limitations making it unusable on a large scale projects;\n  Boost.MSM-lite, therefore, is trying to address those issues.\n\n\n\n\nProblems with Boost.MSM - eUML\n\n\n\n\nLong compilation times (see \nPerformance\n)\n\n\nHuge resulting binaries (see \nPerformance\n)\n\n\nBased on too many macros\n\n\nLong error messages (see \nError Messages\n)\n\n\nSometimes hard to follow as not all actions might be seen on transition table (ex. initial states, state entry/exit actions)\n\n\nA lot of boilerplate code with actions/guards (requires fsm, event, source state, target state)\n\n\nData in states makes it harder to share/encapsulate (UML compliant though)\n\n\nLoosley coupled design is hard to achieve\n\n\nFunctional programming emulation\n\n\nHuge complexity may overwhelm in the beginning\n\n\nA lot of Boost dependencies\n\n\n\n\nBoost.MSM-lite design goals\n\n\n\n\nKeep the Boost.MSM - eUML 'goodies'\n\n\nPerformance (see \nPerformance\n)\n\n\nMemory usage (see \nPerformance\n)\n\n\neUML DSL (src_state + event [ guard ] / action -\n dst_state)\n\n\nUML standard compliant (As much as possible)\n\n\n\n\n\n\n\n\n\n\n\n\nEliminate Boost.MSM - eUML problems\n\n\nCompilation times (see \nPerformance\n)\n\n\nBinary size (see \nPerformance\n)\n\n\nReduce complexity by eliminating less used features\n\n\nShort and informative error messages (see \nError Messages\n)\n\n\nLess boilerplate / no macros (see \nHello World\n)\n\n\nImprove visibility by having all actions on transition table (see \nStates\n)\n\n\nAllows loosely coupled design (see \nDependency Injection\n)\n\n\nFunctional programming support using lamda expressions (see \nAction/Guards\n)\n\n\nNo dependencies / one header (1k lines)\n\n\n\n\n\n\n\n\nWhat 'lite' implies?\n\n\n\n\nMinimal learning curve\n\n\nMaximized performance\n\n\nGuaranteed quick compilation times\n\n\nNo dependencies\n\n\n\n\nSupported\n UML features\n\n\n\n\nTransitions / Internal transitions / Anonymous transitions / No transition (see \nTransitions\n, \nEvents\n)\n\n\nActions / Guards (see \nAction/Guards\n)\n\n\nState entry / exit actions (see \nStates\n)\n\n\nOrthogonal regions (see \nOrthogonal Regions\n)\n\n\nSub / Composite state machines (see \nComposite\n)\n\n\nHistory (see \nHistory\n)\n\n\n\n\nAdditional\n features\n\n\n\n\nLogging (see \nLogging\n)\n\n\nTesting (see \nTesting\n)\n\n\nRuntime Dispatcher (see \nRuntime Dispatcher\n)\n\n\nDependency Injection integration (see \nDependency Injection\n)\n\n\n\n\nRelated materials\n\n\n\n\nCppNow-2016:\n \nC++14 version of Boost.MSM-eUML which compiles up to 60x faster whilst being slightly faster too!\n\n\n\n\nAcknowledgements\n\n\n\n\nThanks to Christophe Henry for a great \nBoost.MSM - eUML\n library\n\n\nThanks to Vicente J. Botet Escriba for useful suggestions how to improve Boost.MSM-lite", 
            "title": "Introduction"
        }, 
        {
            "location": "/index.html#introduction", 
            "text": "Experimental Boost.MSM-lite       Your scalable C++14 header only eUML-like Meta State Machine library with no dependencies ( Try it online! )  GitHub", 
            "title": "Introduction"
        }, 
        {
            "location": "/index.html#uml-state-machine", 
            "text": "State Machine  UML2 Specification  Boost.MSM - eUML", 
            "title": "UML State Machine"
        }, 
        {
            "location": "/index.html#do-i-need-a-state-machine", 
            "text": "State Machine design pattern prevents you from creating and maintaining spaghetti code.  void some_function() {\n    ...\n    if ((is_running   !is_jumping) || just_started) {\n        ...\n    } else if (is_boss_level   extra_feature_enabled   !ab_test) {\n        ...\n    } else {\n        ...\n    }\n}  If above code looks somewhat similar to your code base or if you like\nto avoid it  Boost.MSM-lite  may suit you!", 
            "title": "Do I need a State Machine?"
        }, 
        {
            "location": "/index.html#real-life-examples", 
            "text": "SDL2 Integration Example   Plant UML Example   Logging Example   Testing Example", 
            "title": "Real Life examples?"
        }, 
        {
            "location": "/index.html#why-boostmsm-lite", 
            "text": "Boost.MSM - eUML  is awesome, however it has a few huge limitations making it unusable on a large scale projects;\n  Boost.MSM-lite, therefore, is trying to address those issues.", 
            "title": "Why Boost.MSM-lite?"
        }, 
        {
            "location": "/index.html#problems-with-boostmsm-euml", 
            "text": "Long compilation times (see  Performance )  Huge resulting binaries (see  Performance )  Based on too many macros  Long error messages (see  Error Messages )  Sometimes hard to follow as not all actions might be seen on transition table (ex. initial states, state entry/exit actions)  A lot of boilerplate code with actions/guards (requires fsm, event, source state, target state)  Data in states makes it harder to share/encapsulate (UML compliant though)  Loosley coupled design is hard to achieve  Functional programming emulation  Huge complexity may overwhelm in the beginning  A lot of Boost dependencies", 
            "title": "Problems with Boost.MSM - eUML"
        }, 
        {
            "location": "/index.html#boostmsm-lite-design-goals", 
            "text": "Keep the Boost.MSM - eUML 'goodies'  Performance (see  Performance )  Memory usage (see  Performance )  eUML DSL (src_state + event [ guard ] / action -  dst_state)  UML standard compliant (As much as possible)       Eliminate Boost.MSM - eUML problems  Compilation times (see  Performance )  Binary size (see  Performance )  Reduce complexity by eliminating less used features  Short and informative error messages (see  Error Messages )  Less boilerplate / no macros (see  Hello World )  Improve visibility by having all actions on transition table (see  States )  Allows loosely coupled design (see  Dependency Injection )  Functional programming support using lamda expressions (see  Action/Guards )  No dependencies / one header (1k lines)", 
            "title": "Boost.MSM-lite design goals"
        }, 
        {
            "location": "/index.html#what-lite-implies", 
            "text": "Minimal learning curve  Maximized performance  Guaranteed quick compilation times  No dependencies", 
            "title": "What 'lite' implies?"
        }, 
        {
            "location": "/index.html#supported-uml-features", 
            "text": "Transitions / Internal transitions / Anonymous transitions / No transition (see  Transitions ,  Events )  Actions / Guards (see  Action/Guards )  State entry / exit actions (see  States )  Orthogonal regions (see  Orthogonal Regions )  Sub / Composite state machines (see  Composite )  History (see  History )", 
            "title": "Supported UML features"
        }, 
        {
            "location": "/index.html#additional-features", 
            "text": "Logging (see  Logging )  Testing (see  Testing )  Runtime Dispatcher (see  Runtime Dispatcher )  Dependency Injection integration (see  Dependency Injection )", 
            "title": "Additional features"
        }, 
        {
            "location": "/index.html#related-materials", 
            "text": "CppNow-2016:   C++14 version of Boost.MSM-eUML which compiles up to 60x faster whilst being slightly faster too!", 
            "title": "Related materials"
        }, 
        {
            "location": "/index.html#acknowledgements", 
            "text": "Thanks to Christophe Henry for a great  Boost.MSM - eUML  library  Thanks to Vicente J. Botet Escriba for useful suggestions how to improve Boost.MSM-lite", 
            "title": "Acknowledgements"
        }, 
        {
            "location": "/overview/index.html", 
            "text": "Quick Start\n\n\n\n\nGet \nboost/msm-lite.hpp\n header\n\n\n\n\nwget https://raw.githubusercontent.com/boost-experimental/msm-lite/master/include/boost/msm-lite.hpp\n\n\n\n\n\n\nInclude the header and define \nmsm\n namespace alias\n\n\n\n\n#include \nboost/msm-lite.hpp\n\nnamespace msm = boost::msm::lite;\n\n\n\n\n\n\nCompile with C++14 support\n\n\n\n\n$CXX -std=c++14 ...\n\n\n\n\n\n\nTo run tests\n\n\n\n\ngit clone https://github.com/boost-experimental/msm-lite \n cd msm-lite \n make test\n\n\n\n\nDependencies\n\n\n\n\nNo external dependencies are required (neither STL nor Boost)\n\n\n\n\nSupported/Tested compilers\n\n\n\n\nClang-3.4+\n\n\nGCC-5.2+\n\n\n\n\nConfiguration\n\n\n\n\n\n\n\n\nMacro\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nBOOST_MSM_LITE_VERSION\n\n\nCurrent version of Boost.MSM-lite (ex. 1'0'0)\n\n\n\n\n\n\nBOOST_MSM_LITE_THREAD_SAFE\n\n\nEnables thread safe version (requies STL 'mutex' header)\n\n\n\n\n\n\nBOOST_MSM_LITE_LOG\n\n\nEnables logging system  (see \nLogging\n)\n\n\n\n\n\n\n\n\nException Safety\n\n\n\n\nBoost.MSM-lite doesn't use exceptions internally and therefore might be compiled with \n-fno-exceptions\n.\n\n\nCheck \nUser Guide\n to verify which API's are marked \nnoexcept\n.\n\n\nIf guard/action throws an exception \nState Machine\n will stay in a current state.\n\n\nExceptions might be caught using transition table via \nexception\n event. See \nError handling\n.\n\n\n\n\nThread Safety\n\n\n\n\nBoost.MSM-lite is not thread safe by default.\n  Thread safety might be turned on by \nBOOST_MSM_LITE_THREAD_SAFE\n.\n\n\n\n\nError messages\n\n\nNot configurable\n\n\n#include \nboost/msm-lite.hpp\n\n\nnamespace msm = boost::msm::lite;\n\nstruct e1 {};\n\nstruct not_configurable {\n  auto setup() const noexcept {  // should be configure\n    using namespace msm;\n    return make_transition_table(\n        *\nidle\n_s + event\ne1\n = X\n    );\n  }\n};\n\nint main() {\n  msm::sm\nnot_configurable\n sm;\n  (void)sm;\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/errors/not_configurable.cpp\n\n\n\n\nNot callable\n\n\n#include \nboost/msm-lite.hpp\n\n\nnamespace msm = boost::msm::lite;\n\nstruct e1 {};\n\nstruct im_not_callable {};\n\nstruct not_callable {\n  auto configure() const noexcept {\n    using namespace msm;\n    return make_transition_table(\n        *\nidle\n_s + event\ne1\n / im_not_callable{} = X // not callable\n    );\n  }\n};\n\nint main() {}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/errors/not_callable.cpp\n\n\n\n\nNot transitional\n\n\n#include \nboost/msm-lite.hpp\n\n\nnamespace msm = boost::msm::lite;\n\nstruct e1 {};\nstruct im_not_a_transition {};\n\nstruct not_transitional {\n  auto configure() const noexcept {\n    using namespace msm;\n    return make_transition_table(\n        *\nidle\n_s + event\ne1\n = X\n      , im_not_a_transition{} // not transitional\n    );\n  }\n};\n\nint main() {}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/errors/not_transitional.cpp\n\n\n\n\nNot dispatchable\n\n\n#include \nboost/msm-lite.hpp\n\n\nnamespace msm = boost::msm::lite;\n\nstruct runtime_event {};\nstruct e1 {};  // missing id\n\nstruct not_dispatchable {\n  auto configure() const noexcept {\n    using namespace msm;\n    return make_transition_table(\n        *\nidle\n_s + event\ne1\n = X\n    );\n  }\n};\n\nint main() {\n  msm::sm\nnot_dispatchable\n sm;\n  msm::make_dispatch_table\nruntime_event, 1, 10\n(sm);\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/errors/not_dispatchable.cpp", 
            "title": "Overview"
        }, 
        {
            "location": "/overview/index.html#quick-start", 
            "text": "Get  boost/msm-lite.hpp  header   wget https://raw.githubusercontent.com/boost-experimental/msm-lite/master/include/boost/msm-lite.hpp   Include the header and define  msm  namespace alias   #include  boost/msm-lite.hpp \nnamespace msm = boost::msm::lite;   Compile with C++14 support   $CXX -std=c++14 ...   To run tests   git clone https://github.com/boost-experimental/msm-lite   cd msm-lite   make test", 
            "title": "Quick Start"
        }, 
        {
            "location": "/overview/index.html#dependencies", 
            "text": "No external dependencies are required (neither STL nor Boost)", 
            "title": "Dependencies"
        }, 
        {
            "location": "/overview/index.html#supportedtested-compilers", 
            "text": "Clang-3.4+  GCC-5.2+", 
            "title": "Supported/Tested compilers"
        }, 
        {
            "location": "/overview/index.html#configuration", 
            "text": "Macro  Description      BOOST_MSM_LITE_VERSION  Current version of Boost.MSM-lite (ex. 1'0'0)    BOOST_MSM_LITE_THREAD_SAFE  Enables thread safe version (requies STL 'mutex' header)    BOOST_MSM_LITE_LOG  Enables logging system  (see  Logging )", 
            "title": "Configuration"
        }, 
        {
            "location": "/overview/index.html#exception-safety", 
            "text": "Boost.MSM-lite doesn't use exceptions internally and therefore might be compiled with  -fno-exceptions .  Check  User Guide  to verify which API's are marked  noexcept .  If guard/action throws an exception  State Machine  will stay in a current state.  Exceptions might be caught using transition table via  exception  event. See  Error handling .", 
            "title": "Exception Safety"
        }, 
        {
            "location": "/overview/index.html#thread-safety", 
            "text": "Boost.MSM-lite is not thread safe by default.\n  Thread safety might be turned on by  BOOST_MSM_LITE_THREAD_SAFE .", 
            "title": "Thread Safety"
        }, 
        {
            "location": "/overview/index.html#error-messages", 
            "text": "Not configurable  #include  boost/msm-lite.hpp \n\nnamespace msm = boost::msm::lite;\n\nstruct e1 {};\n\nstruct not_configurable {\n  auto setup() const noexcept {  // should be configure\n    using namespace msm;\n    return make_transition_table(\n        * idle _s + event e1  = X\n    );\n  }\n};\n\nint main() {\n  msm::sm not_configurable  sm;\n  (void)sm;\n}   https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/errors/not_configurable.cpp   Not callable  #include  boost/msm-lite.hpp \n\nnamespace msm = boost::msm::lite;\n\nstruct e1 {};\n\nstruct im_not_callable {};\n\nstruct not_callable {\n  auto configure() const noexcept {\n    using namespace msm;\n    return make_transition_table(\n        * idle _s + event e1  / im_not_callable{} = X // not callable\n    );\n  }\n};\n\nint main() {}   https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/errors/not_callable.cpp   Not transitional  #include  boost/msm-lite.hpp \n\nnamespace msm = boost::msm::lite;\n\nstruct e1 {};\nstruct im_not_a_transition {};\n\nstruct not_transitional {\n  auto configure() const noexcept {\n    using namespace msm;\n    return make_transition_table(\n        * idle _s + event e1  = X\n      , im_not_a_transition{} // not transitional\n    );\n  }\n};\n\nint main() {}   https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/errors/not_transitional.cpp   Not dispatchable  #include  boost/msm-lite.hpp \n\nnamespace msm = boost::msm::lite;\n\nstruct runtime_event {};\nstruct e1 {};  // missing id\n\nstruct not_dispatchable {\n  auto configure() const noexcept {\n    using namespace msm;\n    return make_transition_table(\n        * idle _s + event e1  = X\n    );\n  }\n};\n\nint main() {\n  msm::sm not_dispatchable  sm;\n  msm::make_dispatch_table runtime_event, 1, 10 (sm);\n}   https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/errors/not_dispatchable.cpp", 
            "title": "Error messages"
        }, 
        {
            "location": "/benchmarks/index.html", 
            "text": "Test\n\n\nCXXFLAGS\n\n\nEvents\n\n\nStates\n\n\nTransitions\n\n\nProcess Events\n\n\n\n\n\n\n\n\n\n\nSimple Test\n\n\n-O2 -s\n\n\n6\n\n\n5\n\n\n12\n\n\n1'000'000\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nClang-3.7\n\n\nBoost.MSM-lite\n\n\n[Boost.MSM-eUML]\n\n\n[Boost.MSM3-eUML2]\n\n\n[Boost.Statechart]\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n0.144s\n\n\n3.855s\n\n\n8.699s\n\n\n1.028s\n\n\n\n\n\n\nExecution time\n\n\n15ms\n\n\n17ms\n\n\n17ms\n\n\n1232ms\n\n\n\n\n\n\nMemory usage\n\n\n14b\n\n\n32b\n\n\n28b\n\n\n200b\n\n\n\n\n\n\nExecutable size\n\n\n11K\n\n\n91K\n\n\n15K + boost_system\n\n\n59K\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGCC-5.2\n\n\nBoost.MSM-lite\n\n\n[Boost.MSM-eUML]\n\n\n[Boost.MSM3-eUML2]\n\n\n[Boost.Statechart]\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n0.175s\n\n\n7.879s\n\n\n17.101s\n\n\n1.790s\n\n\n\n\n\n\nExecution time\n\n\n15ms\n\n\n19ms\n\n\n21ms\n\n\n929ms\n\n\n\n\n\n\nMemory usage\n\n\n14b\n\n\n32b\n\n\n28b\n\n\n224b\n\n\n\n\n\n\nExecutable size\n\n\n11K\n\n\n67K\n\n\n15K + boost_system\n\n\n63K\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTest\n\n\nCXXFLAGS\n\n\nEvents\n\n\nStates\n\n\nTransitions\n\n\nProcess Events\n\n\n\n\n\n\n\n\n\n\nComposite Test\n\n\n-O2 -s\n\n\n8\n\n\n5 + 3\n\n\n12 + 4\n\n\n1'000 * 1'000\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nClang-3.7\n\n\nBoost.MSM-lite\n\n\n[Boost.MSM-eUML]\n\n\n[Boost.MSM3-eUML2]\n\n\n[Boost.Statechart]\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n0.184s\n\n\n4.526s\n\n\n10.599s\n\n\n1.293s\n\n\n\n\n\n\nExecution time\n\n\n10ms\n\n\n14ms\n\n\n10ms\n\n\n491ms\n\n\n\n\n\n\nMemory usage\n\n\n20b\n\n\n60b\n\n\n52b\n\n\n200b\n\n\n\n\n\n\nExecutable size\n\n\n15K\n\n\n111K\n\n\n15K + boost_system\n\n\n83K\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGCC-5.2\n\n\nBoost.MSM-lite\n\n\n[Boost.MSM-eUML]\n\n\n[Boost.MSM3-eUML2]\n\n\n[Boost.Statechart]\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n0.248s\n\n\n9.363s\n\n\n23.404s\n\n\n2.037s\n\n\n\n\n\n\nExecution time\n\n\n9ms\n\n\n13ms\n\n\n12ms\n\n\n404ms\n\n\n\n\n\n\nMemory usage\n\n\n20b\n\n\n60b\n\n\n52b\n\n\n224b\n\n\n\n\n\n\nExecutable size\n\n\n12K\n\n\n91K\n\n\n15K + boost_system\n\n\n83K\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTest\n\n\nCXXFLAGS\n\n\nEvents\n\n\nStates\n\n\nTransitions\n\n\nProcess Events\n\n\n\n\n\n\n\n\n\n\nComplex Test\n\n\n-O2 -s\n\n\n50\n\n\n50\n\n\n50\n\n\n1'000'000\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nClang-3.7\n\n\nBoost.MSM-lite\n\n\n[Boost.MSM-eUML]\n\n\n[Boost.MSM3-eUML2]\n\n\n[Boost.Statechart]\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n0.582s\n\n\n1m15.935s\n\n\n43.341s\n\n\n3.661s\n\n\n\n\n\n\nExecution time\n\n\n69ms\n\n\n81ms\n\n\n78ms\n\n\n6221ms\n\n\n\n\n\n\nMemory usage\n\n\n102b\n\n\n120b\n\n\n72b\n\n\n200b\n\n\n\n\n\n\nExecutable size\n\n\n35K\n\n\n611K\n\n\n31K + boost_system\n\n\n343K\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGCC-5.2\n\n\nBoost.MSM-lite\n\n\n[Boost.MSM-eUML]\n\n\n[Boost.MSM3-eUML2]\n\n\n[Boost.Statechart]\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n0.816s\n\n\n52.238s\n\n\n1m41.045s\n\n\n4.997s\n\n\n\n\n\n\nExecution time\n\n\n72ms\n\n\n77ms\n\n\n91ms\n\n\n5520ms\n\n\n\n\n\n\nMemory usage\n\n\n102b\n\n\n120b\n\n\n72b\n\n\n224b\n\n\n\n\n\n\nExecutable size\n\n\n35K\n\n\n271K\n\n\n47K + boost_system\n\n\n215K\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTest\n\n\n\n\n\n\n\n\n\n\nHeader Test\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nClang-3.7\n\n\nBoost.MSM-lite\n\n\n[Boost.MSM-eUML]\n\n\n[Boost.MSM3-eUML2]\n\n\n[Boost.Statechart]\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n0.060s\n\n\n2.072s\n\n\n2.504s\n\n\n0.552s\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGCC-5.2\n\n\nBoost.MSM-lite\n\n\n[Boost.MSM-eUML]\n\n\n[Boost.MSM3-eUML2]\n\n\n[Boost.Statechart]\n\n\n\n\n\n\n\n\n\n\nCompilation time\n\n\n0.073s\n\n\n3.197s\n\n\n3.986s\n\n\n0.704s\n\n\n\n\n\n\n\n\n\n\nTo run benchmarks\n\n\n\n\ncd benchmark \n make # make benchmark_simple benchmark_composite benchmark_complex", 
            "title": "Benchmarks"
        }, 
        {
            "location": "/tutorial/index.html", 
            "text": "All code examples include \nboost/msm-lite.hpp\n as well as declare a convienent msm namespace alias.\n\n\n#include \nboost/msm-lite.hpp\n\nnamespace msm = boost::msm::lite;\n\n\n\n\n0. Read Boost.MSM - eUML documentation\n\n\n\n\nBoost.MSM - UML Short Guide\n\n\nBoost.MSM - eUML Documentation\n\n\n\n\n1. Create events and states\n\n\nState machine is composed of finite number of states and transitions which are triggered via events.\n\n\nAn Event is just a unique type, which will be processed by the state machine.\n\n\nstruct my_event { ... };\n\n\n\n\nYou can also create event instance in order to simplify transition table notation.\n\n\nauto event = msm::event\nmy_event\n;\n\n\n\n\nIf you happen to have a Clang/GCC compiler, you can create an Event on the fly.\n\n\nusing namespace msm;\nauto event  = \nevent\n_t;\n\n\n\n\nHowever, such event will not store any data.\n\n\nA State can have entry/exit behaviour executed whenever machine enters/leaves State and\nrepresents current location of the state machine flow.\n\n\nTo create a state below snippet might be used.\n\n\nmsm::state\nclass idle\n idle;\n// or\nauto idle = msm::state\nclass idle\n{};\n\n\n\n\nIf you happen to have a Clang/GCC compiler, you can create a State on the fly.\n\n\nusing namespace msm;\nauto state  = \nidle\n_s;\n\n\n\n\nHowever, please notice that above solution is a non-standard extension for Clang/GCC.\n\n\nmsm-lite\n states cannot have data as data is injected directly into guards/actions instead.\n\n\nA state machine might be a State itself.\n\n\nmsm::state\nmsm::sm\nstate_machine\n composite;\n\n\n\n\nmsm-lite\n supports \nterminate\n state, which stops events to be processed. It defined by \nX\n.\n\n\n  \nstate\n_s = X;\n\n\n\n\nStates are printable too.\n\n\nassert(string(\nidle\n) == \nidle\n_s.c_str());\n\n\n\n\n\n\n Events Example\n\n\n States Example\n\n\n Composite Example\n\n\n\n\n\n\n\n\n2. Create guards and actions\n\n\nGuards and actions are callable objects which will be executed by the state machine in order to verify whether a transition, followed by an action should take place.\n\n\nGuard MUST return boolean value.\n\n\nauto guard1 = [] {\n  return true;\n};\n\nauto guard2 = [](int, double) { // guard with dependencies\n  return true;\n};\n\nauto guard3 = [](int, auto event, double) { // guard with an event and dependencies\n  return true;\n};\n\nstruct guard4 {\n    bool operator()() const noexcept {\n        return true;\n    }\n};\n\n\n\n\nAction MUST not return.\n\n\nauto action1 = [] { };\nauto action2 = [](int, double) { }; // action with dependencies\nauto action3 = [](int, auto event, double) { }; // action with an event and dependencies\nstruct action4 {\n    void operator()() noexcept { }\n};\n\n\n\n\n\n\n Actions Guards Example\n\n\n\n\n\n\n\n\n3. Create a transition table\n\n\nWhen we have states and events handy we can finally create a transition table which represents\nour transitions.\n\n\nmsm-lite\n is using eUML-like DSL in order to be as close as possible to UML design.\n\n\n\n\n\n\nTransition Table DSL\n\n\n\n\nPostfix Notation\n\n\n\n\n\n\n\n\n\n\nExpression\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstate + event\n [ guard ]\n\n\ninternal transition on event e when guard\n\n\n\n\n\n\nsrc_state / [] {} = dst_state\n\n\nanonymous transition with action\n\n\n\n\n\n\nsrc_state + event\n = dst_state\n\n\ntransition on event e without guard or action\n\n\n\n\n\n\nsrc_state + event\n [ guard ] / action = dst_state\n\n\ntransition from src_state to dst_state on event e with guard and action\n\n\n\n\n\n\nsrc_state + event\n [ guard \n (![]{return true;} \n guard2) ] / (action, action2, []{}) = dst_state\n\n\ntransition from src_state to dst_state on event e with guard and action\n\n\n\n\n\n\n\n\n\n\nPrefix Notation\n\n\n\n\n\n\n\n\n\n\nExpression\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nstate + event\n [ guard ]\n\n\ninternal transition on event e when guard\n\n\n\n\n\n\ndst_state \n= src_state / [] {}\n\n\nanonymous transition with action\n\n\n\n\n\n\ndst_state \n= src_state + event\n\n\ntransition on event e without guard or action\n\n\n\n\n\n\ndst_state \n= src_state + event\n [ guard ] / action\n\n\ntransition from src_state to dst_state on event e with guard and action\n\n\n\n\n\n\ndst_state \n= src_state + event\n [ guard \n (![]{return true;} \n guard2) ] / (action, action2, []{})\n\n\ntransition from src_state to dst_state on event e with guard and action\n\n\n\n\n\n\n\n\n\n\n\n\nTransition flow\n\n\n\n\n\n\nsrc_state + event [ guard ] / action = dst_state\n                                     ^\n                                     |\n                                     |\n                                    1. src_state + on_exit\n                                    2. dst_state + on_entry\n\n\n\n\nTo create a transition table \nmake_transition_table\n is provided.\n\n\nusing namespace msm; // Postfix Notation\n\nmake_transition_table(\n *\nsrc_state\n_s + event\nmy_event\n [ guard ] / action = \ndst_state\n_s\n, \ndst_state\n_s + \nother_event\n_t = X\n);\n\n\n\n\nor\n\n\nusing namespace msm; // Prefix Notation\n\nmake_transition_table(\n  \ndst_state\n_s \n= *\nsrc_state\n_s + event\nmy_event\n [ guard ] / action\n, X             \n= \ndst_state\n_s  + \nother_event\n_t\n);\n\n\n\n\n\n\n Transition Table Example\n\n\n eUML Emulation Example\n\n\n\n\n\n\n\n\n4. Set initial states\n\n\nInitial state tells the state machine where to start. It can be set by prefixing a State with \n*\n.\n\n\nusing namespace msm;\nmake_transition_table(\n *\nsrc_state\n_s + event\nmy_event\n [ guard ] / action = \ndst_state\n_s,\n  \ndst_state\n_s + event\ngame_over\n = X\n);\n\n\n\n\nInitial/Current state might be remembered by the State Machine so that whenever it will reentered\nthe last active state will reactivated. In order to enable history you just have\nto replace \n*\n with postfixed \n(H)\n when declaring the initial state.\n\n\nusing namespace msm;\nmake_transition_table(\n  \nsrc_state\n_s(H) + event\nmy_event\n [ guard ] / action = \ndst_state\n_s,\n  \ndst_state\n_s    + event\ngame_over\n                   = X\n);\n\n\n\n\nYou can have more than one initial state. All initial states will be executed in pseudo-parallel way\n. Such states are called \nOrthogonal regions\n.\n\n\nusing namespace msm;\nmake_transition_table(\n *\nregion_1\n_s   + event\nmy_event1\n [ guard ] / action = \ndst_state1\n_s,\n  \ndst_state1\n_s + event\ngame_over\n = X,\n\n *\nregion_2\n_s   + event\nmy_event2\n [ guard ] / action = \ndst_state2\n_s,\n  \ndst_state2\n_s + event\ngame_over\n = X\n);\n\n\n\n\n\n\n Orthogonal Regions Example\n\n\n History Example\n\n\n\n\n\n\n\n\n5. Create a state machine\n\n\nState machine is an abstraction for transition table holding current states and processing events.\nTo create a state machine, we have to configure our transition table.\n\n\nclass example {\npublic:\n  auto configure() noexcept {\n    using namespace msm;\n    return make_transition_table(\n     *\nsrc_state\n_s + event\nmy_event\n [ guard ] / action = \ndst_state\n_s,\n      \ndst_state\n_s + event\ngame_over\n = X\n    );\n  }\n};\n\n\n\n\nHaving transition table configured we can create a state machine.\n\n\nmsm::sm\nexample\n sm;\n\n\n\n\nState machine constructor provides required dependencies for actions and guards.\n\n\n                            /---- event (injected from process_event)\n                            |\nauto guard = [](double d, auto event) { return true; }\n                   |\n                   \\-------\\\n                           |\nauto action = [](int i){}  |\n                 |         |\n                 |         |\n                 \\-\\   /---/\n                   |   |\nmsm::sm\nexmple\n s{42, 87.0};\n\nmsm::sm\nexmple\n s{87.0, 42}; // order in which parameters have to passed is not specificied\n\n\n\n\nPassing and maintaining a lot of dependencies might be tedious and requires huge amount of boilerplate code.\nIn order to avoid it, Dependency Injection Library might be used to automate this process.\nFor example, we can use \nExperimental Boost.DI\n.\n\n\nauto injector = di::make_injector(\n    di::bind\n.to(42)\n  , di::bind\ninterface\n.to\nimplementation\n()\n);\n\nauto sm = injector.create\nsm\nexample\n();\nassert(sm.process_event(e1{}));\n\n\n\n\n\n\n Hello World Example\n\n\n Dependency Injection Example\n\n\n\n\n\n\n\n\n6. Process events\n\n\nState machine is a simple creature. Its main purpose is to process events.\nIn order to do it, \nprocess_event\n method might be used.\n\n\nmsm::sm\nexample\n sm;\n\nassert(sm.process_event(my_event{})); // returns true when handled\nassert(!sm.process_event(int{})); // not handled by the state machine\n\n\n\n\nProcess event might be also triggered on transition table.\n\n\nusing namespace msm;\nreturn make_transition_table(\n *\ns1\n_s + event\nmy_event\n / process_event(other_event{}) = \ns2\n_s,\n  \ns2\n_s + event\nother_event\n = X\n);\n\n\n\n\nmsm-lite\n also provides a way to dispatch dynamically created events into the state machine.\n\n\nstruct game_over {\n  static constexpr auto id = SDL_QUIT;\n  // explicit game_over(const SDL_Event\n) noexcept; // optional, when defined runtime event will be passed\n};\nenum SDL_EventType { SDL_FIRSTEVENT = 0, SDL_QUIT, SDL_KEYUP, SDL_MOUSEBUTTONUP, SDL_LASTEVENT };\n//create dispatcher from state machine and range of events\nauto dispatch_event = msm::make_dispatch_table\nSDL_Event, SDL_FIRSTEVENT, SDL_LASTEVENT\n(sm);\nSDL_Event event{SDL_QUIT};\nassert(dispatch_event(event, event.type)); // will call sm.process(game_over{});\n\n\n\n\n\n\n Hello World Example\n\n\n Dispatch Table Example\n\n\n SDL2 Integration Example\n\n\n\n\n\n\n\n\n8. Handle errors\n\n\nUnhandled events / transition failed. \nIn such scenario \nprocess_event\n returns false and \nunexpected_event\n is fired.\n\n\nmake_transition_table(\n *\nsrc_state\n_s + event\nmy_event\n [ guard ] / action = \ndst_state\n_s\n, \nsrc_state\n_s + unexpected_event\nsome_event\n = X\n);\n\n\n\n\nUsually, it's handy to create additional \nOrthogonal region\n to cover this scenario,\nThis way State causing unexpected event does not matter.\n\n\nmake_transition_table(\n *\nidle\n_s + event\nmy_event\n [ guard ] / action = \ns1\n_s\n, \ns1\n_s + event\nother_event\n [ guard ] / action = \ns2\n_s\n, \ns2\n_s + event\nyet_another_event\n [ guard ] / action = X\n// terminate (=X) the Machine or reset to another state\n,*\nerror_handler\n_s + unexpected_event\nsome_event\n = X\n);\n\n\n\n\nWe can always check whether a State Machine is in terminate state by.\n\n\nassert(sm.is(msm::X)); // doesn't matter how many regions there are\n\n\n\n\nWhen exceptions are enabled Boost.MSM-lite handles them the same way as unexpected events - via `exception\nevent.\nPlease notice that for performance reasons when exceptions are enabled (__cpp_exceptions defined)\nnoexcept\nshould be added\nonto\nconfigure` in order to disable handling exceptions when they can not be thrown.\n\n\nclass example {\npublic:\n  auto configure() noexcept; // no exceptions handling, terminate will be called on exception\n}\n\n\n\n\nclass example {\npublic:\n  auto configure(); // okay, guards/actions may throw now\n}\n\n\n\n\nmake_transition_table(\n *\nidle\n_s + event\nevent\n / [] { throw std::runtime_error{\nerror\n}; }\n\n,*\nerror_handler\n_s + exception\nstd::runtime_error\n = X\n, \nerror_handler\n_s + exception\nstd::logic_error\n = X\n, \nerror_handler\n_s + exception\n / [] { cleanup...; } = X // any exception\n);\n\n\n\n\n\n\n Error Handling Example\n\n\n\n\n\n\n\n\n9. Test it\n\n\nSometimes it's useful to verify whether a state machine is in a specific state, for example, if\nwe are in a terminate state or not. We can do it with \nmsm-lite\n using \nis\n or \nvisit_current_states\n\nfunctionality.\n\n\nmsm::sm\nexample\n sm;\nassert(sm.process_event(my_event{}));\nassert(sm.is(X)); // is(X, s1, ...) when you have orthogonal regions\n\n//or\n\nsm.visit_current_states([](auto state) { std::cout \n state.c_str() \n std::endl; });\n\n\n\n\nOn top of that, \nmsm-lite\n provides testing facilities to check state machine as a whole.\n\nset_current_states\n method is available from \ntesting::sm\n in order to set state machine\nin a requested state.\n\n\ntesting::sm\nexample\n sm{fake_data...};\nsm.set_current_states(\ns3\n_s); // set_current_states(\ns3\n_s, \ns1\n_s, ...) for orthogonal regions\nassert(sm.process_event(event{}));\nassert(sm.is(X));\n\n\n\n\n\n\n Testing Example\n\n\n\n\n\n\n\n\n10. Debug it\n\n\nmsm-lite\n provides logging capabilities in order to inspect state machine flow.\nTo enable logging you have to define \nBOOST_MSM_LITE_LOG\n.\n\n\ntemplate \nclass SM, class TEvent\n\nvoid log_process_event(const TEvent\n) {\n  printf(\n[%s][process_event] %s\\n\n, typeid(SM).name(), typeid(TEvent).name());\n}\n\ntemplate \nclass SM, class TAction, class TEvent\n\nvoid log_guard(const TAction\n, const TEvent\n, bool result) {\n  printf(\n[%s][guard] %s %s %s\\n\n, typeid(SM).name(), typeid(TAction).name(), typeid(TEvent).name(),\n         (result ? \n[OK]\n : \n[Reject]\n));\n}\n\ntemplate \nclass SM, class TAction, class TEvent\n\nvoid log_action(const TAction\n, const TEvent\n) {\n  printf(\n[%s][action] %s %s\\n\n, typeid(SM).name(), typeid(TAction).name(), typeid(TEvent).name());\n}\n\ntemplate \nclass SM, class TSrcState, class TDstState\n\nvoid log_state_change(const TSrcState\n src, const TDstState\n dst) {\n  printf(\n[%s][transition] %s -\n %s\\n\n, typeid(SM).name(), src.c_str(), dst.c_str());\n}\n\n#define BOOST_MSM_LITE_LOG(T, SM, ...) log_##T\nSM\n(__VA_ARGS__)\n#include \nboost/msm-lite.hpp\n\n\n\n\n\n\n\n Logging Example\n\n\n Plant UML Example", 
            "title": "Tutorial"
        }, 
        {
            "location": "/tutorial/index.html#0-read-boostmsm-euml-documentation", 
            "text": "Boost.MSM - UML Short Guide  Boost.MSM - eUML Documentation", 
            "title": "0. Read Boost.MSM - eUML documentation"
        }, 
        {
            "location": "/tutorial/index.html#1-create-events-and-states", 
            "text": "State machine is composed of finite number of states and transitions which are triggered via events.  An Event is just a unique type, which will be processed by the state machine.  struct my_event { ... };  You can also create event instance in order to simplify transition table notation.  auto event = msm::event my_event ;  If you happen to have a Clang/GCC compiler, you can create an Event on the fly.  using namespace msm;\nauto event  =  event _t;  However, such event will not store any data.  A State can have entry/exit behaviour executed whenever machine enters/leaves State and\nrepresents current location of the state machine flow.  To create a state below snippet might be used.  msm::state class idle  idle;\n// or\nauto idle = msm::state class idle {};  If you happen to have a Clang/GCC compiler, you can create a State on the fly.  using namespace msm;\nauto state  =  idle _s;  However, please notice that above solution is a non-standard extension for Clang/GCC.  msm-lite  states cannot have data as data is injected directly into guards/actions instead.  A state machine might be a State itself.  msm::state msm::sm state_machine  composite;  msm-lite  supports  terminate  state, which stops events to be processed. It defined by  X .     state _s = X;  States are printable too.  assert(string( idle ) ==  idle _s.c_str());    Events Example   States Example   Composite Example", 
            "title": "1. Create events and states"
        }, 
        {
            "location": "/tutorial/index.html#2-create-guards-and-actions", 
            "text": "Guards and actions are callable objects which will be executed by the state machine in order to verify whether a transition, followed by an action should take place.  Guard MUST return boolean value.  auto guard1 = [] {\n  return true;\n};\n\nauto guard2 = [](int, double) { // guard with dependencies\n  return true;\n};\n\nauto guard3 = [](int, auto event, double) { // guard with an event and dependencies\n  return true;\n};\n\nstruct guard4 {\n    bool operator()() const noexcept {\n        return true;\n    }\n};  Action MUST not return.  auto action1 = [] { };\nauto action2 = [](int, double) { }; // action with dependencies\nauto action3 = [](int, auto event, double) { }; // action with an event and dependencies\nstruct action4 {\n    void operator()() noexcept { }\n};    Actions Guards Example", 
            "title": "2. Create guards and actions"
        }, 
        {
            "location": "/tutorial/index.html#3-create-a-transition-table", 
            "text": "When we have states and events handy we can finally create a transition table which represents\nour transitions.  msm-lite  is using eUML-like DSL in order to be as close as possible to UML design.    Transition Table DSL   Postfix Notation      Expression  Description      state + event  [ guard ]  internal transition on event e when guard    src_state / [] {} = dst_state  anonymous transition with action    src_state + event  = dst_state  transition on event e without guard or action    src_state + event  [ guard ] / action = dst_state  transition from src_state to dst_state on event e with guard and action    src_state + event  [ guard   (![]{return true;}   guard2) ] / (action, action2, []{}) = dst_state  transition from src_state to dst_state on event e with guard and action      Prefix Notation      Expression  Description      state + event  [ guard ]  internal transition on event e when guard    dst_state  = src_state / [] {}  anonymous transition with action    dst_state  = src_state + event  transition on event e without guard or action    dst_state  = src_state + event  [ guard ] / action  transition from src_state to dst_state on event e with guard and action    dst_state  = src_state + event  [ guard   (![]{return true;}   guard2) ] / (action, action2, []{})  transition from src_state to dst_state on event e with guard and action       Transition flow    src_state + event [ guard ] / action = dst_state\n                                     ^\n                                     |\n                                     |\n                                    1. src_state + on_exit\n                                    2. dst_state + on_entry  To create a transition table  make_transition_table  is provided.  using namespace msm; // Postfix Notation\n\nmake_transition_table(\n * src_state _s + event my_event  [ guard ] / action =  dst_state _s\n,  dst_state _s +  other_event _t = X\n);  or  using namespace msm; // Prefix Notation\n\nmake_transition_table(\n   dst_state _s  = * src_state _s + event my_event  [ guard ] / action\n, X              =  dst_state _s  +  other_event _t\n);    Transition Table Example   eUML Emulation Example", 
            "title": "3. Create a transition table"
        }, 
        {
            "location": "/tutorial/index.html#4-set-initial-states", 
            "text": "Initial state tells the state machine where to start. It can be set by prefixing a State with  * .  using namespace msm;\nmake_transition_table(\n * src_state _s + event my_event  [ guard ] / action =  dst_state _s,\n   dst_state _s + event game_over  = X\n);  Initial/Current state might be remembered by the State Machine so that whenever it will reentered\nthe last active state will reactivated. In order to enable history you just have\nto replace  *  with postfixed  (H)  when declaring the initial state.  using namespace msm;\nmake_transition_table(\n   src_state _s(H) + event my_event  [ guard ] / action =  dst_state _s,\n   dst_state _s    + event game_over                    = X\n);  You can have more than one initial state. All initial states will be executed in pseudo-parallel way\n. Such states are called  Orthogonal regions .  using namespace msm;\nmake_transition_table(\n * region_1 _s   + event my_event1  [ guard ] / action =  dst_state1 _s,\n   dst_state1 _s + event game_over  = X,\n\n * region_2 _s   + event my_event2  [ guard ] / action =  dst_state2 _s,\n   dst_state2 _s + event game_over  = X\n);    Orthogonal Regions Example   History Example", 
            "title": "4. Set initial states"
        }, 
        {
            "location": "/tutorial/index.html#5-create-a-state-machine", 
            "text": "State machine is an abstraction for transition table holding current states and processing events.\nTo create a state machine, we have to configure our transition table.  class example {\npublic:\n  auto configure() noexcept {\n    using namespace msm;\n    return make_transition_table(\n     * src_state _s + event my_event  [ guard ] / action =  dst_state _s,\n       dst_state _s + event game_over  = X\n    );\n  }\n};  Having transition table configured we can create a state machine.  msm::sm example  sm;  State machine constructor provides required dependencies for actions and guards.                              /---- event (injected from process_event)\n                            |\nauto guard = [](double d, auto event) { return true; }\n                   |\n                   \\-------\\\n                           |\nauto action = [](int i){}  |\n                 |         |\n                 |         |\n                 \\-\\   /---/\n                   |   |\nmsm::sm exmple  s{42, 87.0};\n\nmsm::sm exmple  s{87.0, 42}; // order in which parameters have to passed is not specificied  Passing and maintaining a lot of dependencies might be tedious and requires huge amount of boilerplate code.\nIn order to avoid it, Dependency Injection Library might be used to automate this process.\nFor example, we can use  Experimental Boost.DI .  auto injector = di::make_injector(\n    di::bind .to(42)\n  , di::bind interface .to implementation ()\n);\n\nauto sm = injector.create sm example ();\nassert(sm.process_event(e1{}));    Hello World Example   Dependency Injection Example", 
            "title": "5. Create a state machine"
        }, 
        {
            "location": "/tutorial/index.html#6-process-events", 
            "text": "State machine is a simple creature. Its main purpose is to process events.\nIn order to do it,  process_event  method might be used.  msm::sm example  sm;\n\nassert(sm.process_event(my_event{})); // returns true when handled\nassert(!sm.process_event(int{})); // not handled by the state machine  Process event might be also triggered on transition table.  using namespace msm;\nreturn make_transition_table(\n * s1 _s + event my_event  / process_event(other_event{}) =  s2 _s,\n   s2 _s + event other_event  = X\n);  msm-lite  also provides a way to dispatch dynamically created events into the state machine.  struct game_over {\n  static constexpr auto id = SDL_QUIT;\n  // explicit game_over(const SDL_Event ) noexcept; // optional, when defined runtime event will be passed\n};\nenum SDL_EventType { SDL_FIRSTEVENT = 0, SDL_QUIT, SDL_KEYUP, SDL_MOUSEBUTTONUP, SDL_LASTEVENT };\n//create dispatcher from state machine and range of events\nauto dispatch_event = msm::make_dispatch_table SDL_Event, SDL_FIRSTEVENT, SDL_LASTEVENT (sm);\nSDL_Event event{SDL_QUIT};\nassert(dispatch_event(event, event.type)); // will call sm.process(game_over{});    Hello World Example   Dispatch Table Example   SDL2 Integration Example", 
            "title": "6. Process events"
        }, 
        {
            "location": "/tutorial/index.html#8-handle-errors", 
            "text": "Unhandled events / transition failed. \nIn such scenario  process_event  returns false and  unexpected_event  is fired.  make_transition_table(\n * src_state _s + event my_event  [ guard ] / action =  dst_state _s\n,  src_state _s + unexpected_event some_event  = X\n);  Usually, it's handy to create additional  Orthogonal region  to cover this scenario,\nThis way State causing unexpected event does not matter.  make_transition_table(\n * idle _s + event my_event  [ guard ] / action =  s1 _s\n,  s1 _s + event other_event  [ guard ] / action =  s2 _s\n,  s2 _s + event yet_another_event  [ guard ] / action = X\n// terminate (=X) the Machine or reset to another state\n,* error_handler _s + unexpected_event some_event  = X\n);  We can always check whether a State Machine is in terminate state by.  assert(sm.is(msm::X)); // doesn't matter how many regions there are  When exceptions are enabled Boost.MSM-lite handles them the same way as unexpected events - via `exception event.\nPlease notice that for performance reasons when exceptions are enabled (__cpp_exceptions defined) noexcept should be added\nonto configure` in order to disable handling exceptions when they can not be thrown.  class example {\npublic:\n  auto configure() noexcept; // no exceptions handling, terminate will be called on exception\n}  class example {\npublic:\n  auto configure(); // okay, guards/actions may throw now\n}  make_transition_table(\n * idle _s + event event  / [] { throw std::runtime_error{ error }; }\n\n,* error_handler _s + exception std::runtime_error  = X\n,  error_handler _s + exception std::logic_error  = X\n,  error_handler _s + exception  / [] { cleanup...; } = X // any exception\n);    Error Handling Example", 
            "title": "8. Handle errors"
        }, 
        {
            "location": "/tutorial/index.html#9-test-it", 
            "text": "Sometimes it's useful to verify whether a state machine is in a specific state, for example, if\nwe are in a terminate state or not. We can do it with  msm-lite  using  is  or  visit_current_states \nfunctionality.  msm::sm example  sm;\nassert(sm.process_event(my_event{}));\nassert(sm.is(X)); // is(X, s1, ...) when you have orthogonal regions\n\n//or\n\nsm.visit_current_states([](auto state) { std::cout   state.c_str()   std::endl; });  On top of that,  msm-lite  provides testing facilities to check state machine as a whole. set_current_states  method is available from  testing::sm  in order to set state machine\nin a requested state.  testing::sm example  sm{fake_data...};\nsm.set_current_states( s3 _s); // set_current_states( s3 _s,  s1 _s, ...) for orthogonal regions\nassert(sm.process_event(event{}));\nassert(sm.is(X));    Testing Example", 
            "title": "9. Test it"
        }, 
        {
            "location": "/tutorial/index.html#10-debug-it", 
            "text": "msm-lite  provides logging capabilities in order to inspect state machine flow.\nTo enable logging you have to define  BOOST_MSM_LITE_LOG .  template  class SM, class TEvent \nvoid log_process_event(const TEvent ) {\n  printf( [%s][process_event] %s\\n , typeid(SM).name(), typeid(TEvent).name());\n}\n\ntemplate  class SM, class TAction, class TEvent \nvoid log_guard(const TAction , const TEvent , bool result) {\n  printf( [%s][guard] %s %s %s\\n , typeid(SM).name(), typeid(TAction).name(), typeid(TEvent).name(),\n         (result ?  [OK]  :  [Reject] ));\n}\n\ntemplate  class SM, class TAction, class TEvent \nvoid log_action(const TAction , const TEvent ) {\n  printf( [%s][action] %s %s\\n , typeid(SM).name(), typeid(TAction).name(), typeid(TEvent).name());\n}\n\ntemplate  class SM, class TSrcState, class TDstState \nvoid log_state_change(const TSrcState  src, const TDstState  dst) {\n  printf( [%s][transition] %s -  %s\\n , typeid(SM).name(), src.c_str(), dst.c_str());\n}\n\n#define BOOST_MSM_LITE_LOG(T, SM, ...) log_##T SM (__VA_ARGS__)\n#include  boost/msm-lite.hpp     Logging Example   Plant UML Example", 
            "title": "10. Debug it"
        }, 
        {
            "location": "/user_guide/index.html", 
            "text": "transitional [concept]\n\n\nHeader\n\n\n#include \nboost/msm-lite.hpp\n\n\n\n\nDescription\n\n\nRequirements for transition.\n\n\nSynopsis\n\n\ntemplate \nclass T\n\nconcept bool transitional() {\n  return requires(T transition) {\n    typename T::src_state;\n    typename T::dst_state;\n    typename T::event;\n    typename T::deps;\n    T::initial;\n    T::history;\n    { transition.execute() } -\n bool;\n  }\n}\n\n\n\nSemantics\n\n\ntransitional\nT\n\n\n\n\nExample\n\n\nusing namespace msm;\n\n{\nauto transition = (\"idle\"_s = X); // Postfix Notation\nstatic_assert(transitional\ndecltype(transition)\n::value);\n}\n\n{\nauto transition = (X \n= \"idle\"_s); // Prefix Notation\nstatic_assert(transitional\ndecltype(transition)\n::value);\n}\n\n\n\n\n\n Transitional Example\n\n\n\n\n\n\n\n\nconfigurable [concept]\n\n\nHeader\n\n\n#include \nboost/msm-lite.hpp\n\n\n\n\nDescription\n\n\nRequirements for the state machine.\n\n\nSynopsis\n\n\ntemplate \nclass SM\n\nconcept bool configurable() {\n  return requires(SM sm) {\n    { sm.configure() };\n  }\n}\n\n\n\nSemantics\n\n\nconfigurable\nSM\n\n\n\n\nExample\n\n\nclass example {\n  auto configure() const noexcept {\n    return make_transition_table();\n  }\n};\n\nstatic_assert(configurable\nexample\n::value);\n\n\n\n\n\n Configurable Example\n\n\n\n\n\n\n\n\ncallable [concept]\n\n\nHeader\n\n\n#include \nboost/msm-lite.hpp\n\n\n\n\nDescription\n\n\nRequirements for action and guards.\n\n\nSynopsis\n\n\ntemplate \nclass TResult, class T\n\nconcept bool callable() {\n  return requires(T object) {\n    { object(...) } -\n TResult;\n  }\n}\n\n\n\nSemantics\n\n\ncallable\nSM\n\n\n\n\nExample\n\n\nauto guard = [] { return true; };\nauto action = [] { };\n\nstatic_assert(callable\nbool, decltype(guard)\n::value);\nstatic_assert(callable\nvoid, decltype(action)\n::value);\n\n\n\n\n\n Callable Example\n\n\n\n\n\n\n\n\ndispatchable [concept]\n\n\nHeader\n\n\n#include \nboost/msm-lite.hpp\n\n\n\n\nDescription\n\n\nRequirements for the dispatch table.\n\n\nSynopsis\n\n\ntemplate \nclass TDynamicEvent, TEvent\n\nconcept bool dispatchable() {\n  return requires(T) {\n    typename TEvent::id;\n    { TEvent(declval\nTDynamicEvent\n()) };\n  }\n}\n\n\n\nSemantics\n\n\ndispatchable\nSM\n\n\n\n\nExample\n\n\nstruct runtime_event { };\n\nstruct event1 {\n  static constexpr auto id = 1;\n};\n\nstruct event2 {\n  static constexpr auto id = 2;\n  explicit event2(const runtime_event\n) {}\n};\n\nstatic_assert(dispatchable\nruntime_event, event1\n::value);\nstatic_assert(dispatchable\nruntime_event, event2\n::value);\n\n\n\n\n\n Dispatchable Example\n\n\n SDL2 Integration Example\n\n\n\n\n\n\n\n\nstate [core]\n\n\nHeader\n\n\n#include \nboost/msm-lite.hpp\n\n\n\n\nDescription\n\n\nRepresents a state machine state.\n\n\nSynopsis\n\n\ntemplate\nclass TState\n // no requirements, TState may be a state machine\nclass state {\npublic:\n  initial operator*() const noexcept; // no requirements\n\n  template \nclass T\n // no requirements\n  auto operator\n=(const T \n) const noexcept;\n\n  template \nclass T\n // no requirements\n  auto operator=(const T \n) const noexcept;\n\n  template \nclass T\n // no requirements\n  auto operator+(const T \n) const noexcept;\n\n  template \nclass T\n requires callable\nbool, T\n\n  auto operator[](const T) const noexcept;\n\n  template \nclass T\n requires callable\nvoid, T\n\n  auto operator/(const T \nt) const noexcept;\n\n  const char* c_str() noexcept;\n};\n\ntemplate \nclass T, T... Chrs\n\nstate\nunspecified\n operator\"\"_s() noexcept;\n\n// predefined states\nstate\nunspecified\n X;\n\n\n\nRequirements\n\n\n\n\ncallable\n\n\n\n\nSemantics\n\n\nstate\nT\n{}\n\n\n\nExample\n\n\nstate\nclass idle\n idle;\nauto idle = state\nclass idle\n{};\nauto idle = \"idle\"_s;\n\nauto initial_state = *idle;\nauto history_state = idle(H);\nauto terminate_state = X;\n\n\n\n\n\n States Example\n\n\n Composite Example\n\n\n Orthogonal Regions Example\n\n\n\n\n\n\n\n\nevent [core]\n\n\nHeader\n\n\n#include \nboost/msm-lite.hpp\n\n\n\n\nDescription\n\n\nRepresents a state machine event.\n\n\nSynopsis\n\n\ntemplate\nTEvent\n // no requirements\nclass event {\npublic:\n  template \nclass T\n requires callable\nbool, T\n\n  auto operator[](const T \n) const noexcept;\n\n  template \nclass T\n requires callable\nvoid, T\n\n  auto operator/(const T \nt) const noexcept;\n};\n\ntemplate\nclass TEvent\n\nevent\nTEvent\n event{};\n\n// predefined events\nauto on_entry = event\nunspecified\n;\nauto on_exit = event\nunspecified\n;\n\ntemplate\nclass TEvent\n unexpected_event{};\ntemplate\nclass T\n exception{};\n\n\n\nRequirements\n\n\n\n\ncallable\n\n\n\n\nSemantics\n\n\nevent\nT\n\n\n\n\nExample\n\n\nauto my_int_event = event\nint\n;\n\n\n\n\n\n Events Example\n\n\n Error Handling Example\n\n\n\n\n\n\n\n\nmake_transition_table [state machine]\n\n\nHeader\n\n\n#include \nboost/msm-lite.hpp\n\n\n\n\nDescription\n\n\nCreates a transition table.\n\n\nSynopsis\n\n\ntemplate \nclass... Ts\n requires transitional\nTs\n...\nauto make_transition_table(Ts...) noexcept;\n\n\n\nRequirements\n\n\n\n\ntransitional\n\n\n\n\nSemantics\n\n\nmake_transition_table(transitions...);\n\n\n\nExample\n\n\nauto transition_table_postfix_notation = make_transition_table(\n  *\"idle_s\" + event\nint\n / [] {} = X\n);\n\nauto transition_table_prefix_notation = make_transition_table(\n  X \n= *\"idle_s\" + event\nint\n / [] {}\n);\n\nclass example {\npublic:\n  auto configure() const noexcept {\n    return make_transition_table();\n  }\n};\n\n\n\n\n\n Transition Table Example\n\n\n\n\n\n\n\n\nsm [state machine]\n\n\nHeader\n\n\n#include \nboost/msm-lite.hpp\n\n\n\n\nDescription\n\n\nCreates a State Machine.\n\n\nSynopsis\n\n\ntemplate\nclass T\n requires configurable\nT\n\nclass sm {\npublic:\n  using states = unspecified; // unique list of states\n  using events = unspecified; // unique list of events which can be handled by the State Machine\n  using transitions = unspecified; // list of transitions\n\n  sm(sm \n) = default;\n  sm(const sm \n) = delete;\n  sm \noperator=(const sm \n) = delete;\n\n  template \nclass... TDeps\n requires is_base_of\nTDeps, dependencies\n...\n  sm(TDeps\n...) noexcept;\n\n  template\nclass TEvent\n // no requirements\n  bool process_event(const TEvent\n) noexcept(noexcept(T.configure()))\n\n  template \nclass TVisitor\n requires callable\nvoid, TVisitor\n\n  void visit_current_states(const TVisitor \n) const noexcept(noexcept(visitor(state{})));\n\n  template \nclass TState\n\n  bool is(const state\nTState\n \n) const noexcept;\n\n  template \nclass... TStates\n requires sizeof...(TStates) == number_of_initial_states\n  bool is(const state\nTStates\n \n...) const noexcept;\n};\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nTDeps...\n\n\nis_base_of dependencies\n\n\nconstructor\n\n\n\n\n\n\n\n\nprocess_event\nTEvent\n\n\n-\n\n\nprocess event \nTEvent\n\n\nreturns true when handled, false otherwise\n\n\n\n\n\n\nvisit_current_states\nTVisitor\n\n\ncallable\n\n\nvisit current states\n\n\n-\n\n\n\n\n\n\nis\nTState\n\n\n-\n\n\nverify whether any of current states equals \nTState\n\n\ntrue when any current state matches \nTState\n, false otherwise\n\n\n\n\n\n\nis\nTStates...\n\n\nsize of TStates... equals number of initial states\n\n\nverify whether all current states match \nTStates...\n\n\ntrue when all states match \nTState...\n, false otherwise\n\n\n\n\n\n\n\n\nSemantics\n\n\nmsm::sm\nT\n{...};\nsm.process_event(TEvent{});\nsm.visit_current_states([](auto state){});\nsm.is(X);\nsm.is(s1, s2);\n\n\n\nExample\n\n\nstruct my_event {};\n\nclass example {\npublic:\n  auto configure() const noexcept {\n  using namespace msm;\n    return make_transition_table(\n      *\"idle\"_s + event\nmy_event\n / [](int i) { std::cout \n i \n std::endl; } = X\n    );\n  }\n};\n\nmsm::sm\nexample\n sm{42};\nassert(sm.is(\"idle\"_s));\nassert(!sm.process_event(int{})); // no handled\nassert(sm.process_event(my_event{})); // handled\nassert(sm.is(X));\n\nsm.visit_current_states([](auto state) { std::cout \n state.c_str() \n std::endl; });\n\n\n\n\n\n Hello World Example\n\n\n Dependency Injection Example\n\n\n eUML Emulation Example\n\n\n\n\n\n\n\n\ntesting::sm [testing]\n\n\nHeader\n\n\n#include \nboost/msm-lite.hpp\n\n\n\n\nDescription\n\n\nCreates a state machine with testing capabilities.\n\n\nSynopsis\n\n\nnamespace testing {\n  template \nclass T\n\n  class sm : public msm::sm\nT\n {\n   public:\n    using msm::sm\nT\n::sm;\n\n    template \nclass... TStates\n\n    void set_current_states(const detail::state\nTStates\n \n...) noexcept;\n  };\n}\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nset_current_states\nTStates...\n\n\n-\n\n\nset current states\n\n\n\n\n\n\n\n\n\n\nSemantics\n\n\nmsm::testing::sm\nT\n{...};\nsm.set_current_states(\"s1\"_s);\n\n\n\nExample\n\n\nmsm::testing::sm\nT\n{inject_fake_data...};\nsm.set_current_states(\"s1\"_s);\nsm.process_event(TEvent{});\nsm.is(X);\n\n\n\n\n\n Testing Example\n\n\n\n\n\n\n\n\nmake_dispatch_table [utility]\n\n\nHeader\n\n\n#include \nboost/msm-lite.hpp\n\n\n\n\nDescription\n\n\nCreates a dispatch table to handle runtime events.\n\n\nSynopsis\n\n\ntemplate\nclass TEvent, int EventRangeBegin, int EventRangeBegin, class SM\n requires dispatchable\nTEvent, typename SM::events\n\ncallable\nbool, (TEvent, int)\n make_dispatch_table(sm\nSM\n) noexcept;\n\n\n\nRequirements\n\n\n\n\ndispatchable\n\n\n\n\nSemantics\n\n\nmake_dispatch_table\nT, 0, 10\n(sm);\n\n\n\nExample\n\n\nstruct runtime_event {\n  int id = 0;\n};\nstruct event1 {\n  static constexpr auto id = 1;\n  event1(const runtime_event \n) {}\n};\n\nauto dispatch_event = msm::make_dispatch_table\nruntime_event, 1 /*min*/, 5 /*max*/\n(sm);\nassert(dispatch_event(event, event.id));\n\n\n\n\n\n Dispatch Table Example\n\n\n SDL2 Integration Example\n\n\n\n\n\n\n\n\nBOOST_MSM_LITE_LOG [debugging]\n\n\nHeader\n\n\n#include \nboost/msm-lite.hpp\n\n\n\n\nDescription\n\n\nAdd logging support for the state machine.\n\n\nSynopsis\n\n\n#define BOOST_MSM_LITE_LOG(T, SM, ...)\n\n\n\n\n\n\n\n\n\nExpression\n\n\nRequirement\n\n\nDescription\n\n\nReturns\n\n\n\n\n\n\n\n\n\n\nT\n\n\n-\n\n\nprocess_event/guard/action/state_change\n\n\nOperation type\n\n\n\n\n\n\nSM\n\n\n-\n\n\n-\n\n\nstate machine\n type\n\n\n\n\n\n\n...\n\n\n-\n\n\nprocess_event -\n (event)\n\n\nlog process event\n\n\n\n\n\n\n...\n\n\n-\n\n\nguard -\n (guard, event, result)\n\n\nlog guard call\n\n\n\n\n\n\n...\n\n\n-\n\n\naction -\n (action, event)\n\n\nlog action call\n\n\n\n\n\n\n...\n\n\n-\n\n\nstate_change -\n (src_state, dst_state)\n\n\nlog state change\n\n\n\n\n\n\n\n\nSemantics\n\n\nBOOST_MSM_LITE_LOG(state_change, sm\nexample\n, current_state, new_state)\n\n\n\nExample\n\n\nvoid log(const char* operation, ...) noexcept {\n    printf(\"[%s]\\n\", operation);\n}\n#define BOOST_MSM_LITE_LOG(T, ...) log(#T)\n#include \"boost/msm-lite.hpp\"\n\nmsm::sm\nexample\n sm;\nsm.process_event(event{}); // [process_event]\n\n\n\n\n\n Logging Example\n\n\n Plant UML Example", 
            "title": "User Guide"
        }, 
        {
            "location": "/user_guide/index.html#transitional-concept", 
            "text": "Header  #include  boost/msm-lite.hpp   Description  Requirements for transition.  Synopsis  template  class T \nconcept bool transitional() {\n  return requires(T transition) {\n    typename T::src_state;\n    typename T::dst_state;\n    typename T::event;\n    typename T::deps;\n    T::initial;\n    T::history;\n    { transition.execute() } -  bool;\n  }\n}  Semantics  transitional T   Example  using namespace msm;\n\n{\nauto transition = (\"idle\"_s = X); // Postfix Notation\nstatic_assert(transitional decltype(transition) ::value);\n}\n\n{\nauto transition = (X  = \"idle\"_s); // Prefix Notation\nstatic_assert(transitional decltype(transition) ::value);\n}    Transitional Example", 
            "title": "transitional [concept]"
        }, 
        {
            "location": "/user_guide/index.html#configurable-concept", 
            "text": "Header  #include  boost/msm-lite.hpp   Description  Requirements for the state machine.  Synopsis  template  class SM \nconcept bool configurable() {\n  return requires(SM sm) {\n    { sm.configure() };\n  }\n}  Semantics  configurable SM   Example  class example {\n  auto configure() const noexcept {\n    return make_transition_table();\n  }\n};\n\nstatic_assert(configurable example ::value);    Configurable Example", 
            "title": "configurable [concept]"
        }, 
        {
            "location": "/user_guide/index.html#callable-concept", 
            "text": "Header  #include  boost/msm-lite.hpp   Description  Requirements for action and guards.  Synopsis  template  class TResult, class T \nconcept bool callable() {\n  return requires(T object) {\n    { object(...) } -  TResult;\n  }\n}  Semantics  callable SM   Example  auto guard = [] { return true; };\nauto action = [] { };\n\nstatic_assert(callable bool, decltype(guard) ::value);\nstatic_assert(callable void, decltype(action) ::value);    Callable Example", 
            "title": "callable [concept]"
        }, 
        {
            "location": "/user_guide/index.html#dispatchable-concept", 
            "text": "Header  #include  boost/msm-lite.hpp   Description  Requirements for the dispatch table.  Synopsis  template  class TDynamicEvent, TEvent \nconcept bool dispatchable() {\n  return requires(T) {\n    typename TEvent::id;\n    { TEvent(declval TDynamicEvent ()) };\n  }\n}  Semantics  dispatchable SM   Example  struct runtime_event { };\n\nstruct event1 {\n  static constexpr auto id = 1;\n};\n\nstruct event2 {\n  static constexpr auto id = 2;\n  explicit event2(const runtime_event ) {}\n};\n\nstatic_assert(dispatchable runtime_event, event1 ::value);\nstatic_assert(dispatchable runtime_event, event2 ::value);    Dispatchable Example   SDL2 Integration Example", 
            "title": "dispatchable [concept]"
        }, 
        {
            "location": "/user_guide/index.html#state-core", 
            "text": "Header  #include  boost/msm-lite.hpp   Description  Represents a state machine state.  Synopsis  template class TState  // no requirements, TState may be a state machine\nclass state {\npublic:\n  initial operator*() const noexcept; // no requirements\n\n  template  class T  // no requirements\n  auto operator =(const T  ) const noexcept;\n\n  template  class T  // no requirements\n  auto operator=(const T  ) const noexcept;\n\n  template  class T  // no requirements\n  auto operator+(const T  ) const noexcept;\n\n  template  class T  requires callable bool, T \n  auto operator[](const T) const noexcept;\n\n  template  class T  requires callable void, T \n  auto operator/(const T  t) const noexcept;\n\n  const char* c_str() noexcept;\n};\n\ntemplate  class T, T... Chrs \nstate unspecified  operator\"\"_s() noexcept;\n\n// predefined states\nstate unspecified  X;  Requirements   callable   Semantics  state T {}  Example  state class idle  idle;\nauto idle = state class idle {};\nauto idle = \"idle\"_s;\n\nauto initial_state = *idle;\nauto history_state = idle(H);\nauto terminate_state = X;    States Example   Composite Example   Orthogonal Regions Example", 
            "title": "state [core]"
        }, 
        {
            "location": "/user_guide/index.html#event-core", 
            "text": "Header  #include  boost/msm-lite.hpp   Description  Represents a state machine event.  Synopsis  template TEvent  // no requirements\nclass event {\npublic:\n  template  class T  requires callable bool, T \n  auto operator[](const T  ) const noexcept;\n\n  template  class T  requires callable void, T \n  auto operator/(const T  t) const noexcept;\n};\n\ntemplate class TEvent \nevent TEvent  event{};\n\n// predefined events\nauto on_entry = event unspecified ;\nauto on_exit = event unspecified ;\n\ntemplate class TEvent  unexpected_event{};\ntemplate class T  exception{};  Requirements   callable   Semantics  event T   Example  auto my_int_event = event int ;    Events Example   Error Handling Example", 
            "title": "event [core]"
        }, 
        {
            "location": "/user_guide/index.html#make_transition_table-state-machine", 
            "text": "Header  #include  boost/msm-lite.hpp   Description  Creates a transition table.  Synopsis  template  class... Ts  requires transitional Ts ...\nauto make_transition_table(Ts...) noexcept;  Requirements   transitional   Semantics  make_transition_table(transitions...);  Example  auto transition_table_postfix_notation = make_transition_table(\n  *\"idle_s\" + event int  / [] {} = X\n);\n\nauto transition_table_prefix_notation = make_transition_table(\n  X  = *\"idle_s\" + event int  / [] {}\n);\n\nclass example {\npublic:\n  auto configure() const noexcept {\n    return make_transition_table();\n  }\n};    Transition Table Example", 
            "title": "make_transition_table [state machine]"
        }, 
        {
            "location": "/user_guide/index.html#sm-state-machine", 
            "text": "Header  #include  boost/msm-lite.hpp   Description  Creates a State Machine.  Synopsis  template class T  requires configurable T \nclass sm {\npublic:\n  using states = unspecified; // unique list of states\n  using events = unspecified; // unique list of events which can be handled by the State Machine\n  using transitions = unspecified; // list of transitions\n\n  sm(sm  ) = default;\n  sm(const sm  ) = delete;\n  sm  operator=(const sm  ) = delete;\n\n  template  class... TDeps  requires is_base_of TDeps, dependencies ...\n  sm(TDeps ...) noexcept;\n\n  template class TEvent  // no requirements\n  bool process_event(const TEvent ) noexcept(noexcept(T.configure()))\n\n  template  class TVisitor  requires callable void, TVisitor \n  void visit_current_states(const TVisitor  ) const noexcept(noexcept(visitor(state{})));\n\n  template  class TState \n  bool is(const state TState   ) const noexcept;\n\n  template  class... TStates  requires sizeof...(TStates) == number_of_initial_states\n  bool is(const state TStates   ...) const noexcept;\n};     Expression  Requirement  Description  Returns      TDeps...  is_base_of dependencies  constructor     process_event TEvent  -  process event  TEvent  returns true when handled, false otherwise    visit_current_states TVisitor  callable  visit current states  -    is TState  -  verify whether any of current states equals  TState  true when any current state matches  TState , false otherwise    is TStates...  size of TStates... equals number of initial states  verify whether all current states match  TStates...  true when all states match  TState... , false otherwise     Semantics  msm::sm T {...};\nsm.process_event(TEvent{});\nsm.visit_current_states([](auto state){});\nsm.is(X);\nsm.is(s1, s2);  Example  struct my_event {};\n\nclass example {\npublic:\n  auto configure() const noexcept {\n  using namespace msm;\n    return make_transition_table(\n      *\"idle\"_s + event my_event  / [](int i) { std::cout   i   std::endl; } = X\n    );\n  }\n};\n\nmsm::sm example  sm{42};\nassert(sm.is(\"idle\"_s));\nassert(!sm.process_event(int{})); // no handled\nassert(sm.process_event(my_event{})); // handled\nassert(sm.is(X));\n\nsm.visit_current_states([](auto state) { std::cout   state.c_str()   std::endl; });    Hello World Example   Dependency Injection Example   eUML Emulation Example", 
            "title": "sm [state machine]"
        }, 
        {
            "location": "/user_guide/index.html#testingsm-testing", 
            "text": "Header  #include  boost/msm-lite.hpp   Description  Creates a state machine with testing capabilities.  Synopsis  namespace testing {\n  template  class T \n  class sm : public msm::sm T  {\n   public:\n    using msm::sm T ::sm;\n\n    template  class... TStates \n    void set_current_states(const detail::state TStates   ...) noexcept;\n  };\n}     Expression  Requirement  Description  Returns      set_current_states TStates...  -  set current states      Semantics  msm::testing::sm T {...};\nsm.set_current_states(\"s1\"_s);  Example  msm::testing::sm T {inject_fake_data...};\nsm.set_current_states(\"s1\"_s);\nsm.process_event(TEvent{});\nsm.is(X);    Testing Example", 
            "title": "testing::sm [testing]"
        }, 
        {
            "location": "/user_guide/index.html#make_dispatch_table-utility", 
            "text": "Header  #include  boost/msm-lite.hpp   Description  Creates a dispatch table to handle runtime events.  Synopsis  template class TEvent, int EventRangeBegin, int EventRangeBegin, class SM  requires dispatchable TEvent, typename SM::events \ncallable bool, (TEvent, int)  make_dispatch_table(sm SM ) noexcept;  Requirements   dispatchable   Semantics  make_dispatch_table T, 0, 10 (sm);  Example  struct runtime_event {\n  int id = 0;\n};\nstruct event1 {\n  static constexpr auto id = 1;\n  event1(const runtime_event  ) {}\n};\n\nauto dispatch_event = msm::make_dispatch_table runtime_event, 1 /*min*/, 5 /*max*/ (sm);\nassert(dispatch_event(event, event.id));    Dispatch Table Example   SDL2 Integration Example", 
            "title": "make_dispatch_table [utility]"
        }, 
        {
            "location": "/user_guide/index.html#boost_msm_lite_log-debugging", 
            "text": "Header  #include  boost/msm-lite.hpp   Description  Add logging support for the state machine.  Synopsis  #define BOOST_MSM_LITE_LOG(T, SM, ...)     Expression  Requirement  Description  Returns      T  -  process_event/guard/action/state_change  Operation type    SM  -  -  state machine  type    ...  -  process_event -  (event)  log process event    ...  -  guard -  (guard, event, result)  log guard call    ...  -  action -  (action, event)  log action call    ...  -  state_change -  (src_state, dst_state)  log state change     Semantics  BOOST_MSM_LITE_LOG(state_change, sm example , current_state, new_state)  Example  void log(const char* operation, ...) noexcept {\n    printf(\"[%s]\\n\", operation);\n}\n#define BOOST_MSM_LITE_LOG(T, ...) log(#T)\n#include \"boost/msm-lite.hpp\"\n\nmsm::sm example  sm;\nsm.process_event(event{}); // [process_event]    Logging Example   Plant UML Example", 
            "title": "BOOST_MSM_LITE_LOG [debugging]"
        }, 
        {
            "location": "/examples/index.html", 
            "text": "Hello World\n\n\nEvents\n\n\nStates\n\n\nActions Guards\n\n\nTransitions\n\n\nOrthogonal Regions\n\n\nComposite\n\n\nHistory\n\n\nError handling\n\n\nLogging\n\n\nTesting\n\n\nRuntime Dispatcher\n\n\neUML Emulation\n\n\nDependency Injection\n\n\nSDL2 Integration\n\n\nPlant UML Integration\n\n\n\n\n\n\nHello World\n\n\n#include \nboost/msm-lite.hpp\n\n#include \ncassert\n\n#include \niostream\n\n\nnamespace msm = boost::msm::lite;\n\nstruct e1 {};\nstruct e2 {};\nstruct e3 {};\n\nauto guard = [] {\n  std::cout \n \nguard\n \n std::endl;\n  return true;\n};\n\nauto action = [] { std::cout \n \naction\n \n std::endl; };\n\nstruct hello_world {\n  auto configure() const noexcept {\n    using namespace msm;\n    return make_transition_table(\n       *\nidle\n_s + event\ne1\n = \ns1\n_s\n      , \ns1\n_s + event\ne2\n [ guard ] / action = \ns2\n_s\n      , \ns2\n_s + event\ne3\n / [] { std::cout \n \nin place action\n \n std::endl; } = X\n    );\n  }\n};\n\nint main() {\n  msm::sm\nhello_world\n sm;\n  using namespace msm;\n  assert(sm.is(\nidle\n_s));\n  assert(sm.process_event(e1{}));\n  assert(sm.is(\ns1\n_s));\n  assert(sm.process_event(e2{}));\n  assert(sm.is(\ns2\n_s));\n  assert(sm.process_event(e3{}));\n  assert(sm.is(X));\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/hello_world.cpp\n\n\n\n\nEvents\n\n\n#include \nboost/msm-lite.hpp\n\n#include \ncassert\n\n\nnamespace msm = boost::msm::lite;\n\nstruct e1 {};\nstruct e2 {\n  bool value = true;\n};\nauto event2 = msm::event\ne2\n;\n\nstruct events {\n  auto configure() const noexcept {\n    using namespace msm;\n    auto guard = [](const e2\n e) { return e.value; };\n\n    return make_transition_table(\n       *\nidle\n_s + event\ne1\n = \ns1\n_s\n      , \ns1\n_s + event2 [guard] = \ns2\n_s\n      , \ns2\n_s + \ne3\n_t = \ns3\n_s\n      , \ns3\n_s + event\nint\n / [] (int i) { assert(42 == i); } = X\n    );\n  }\n};\n\nint main() {\n  msm::sm\nevents\n sm;\n  using namespace msm;\n  assert(sm.process_event(e1{}));\n  assert(sm.process_event(e2{}));\n  assert(sm.process_event(\ne3\n_t));\n  assert(sm.process_event(42));\n  assert(sm.is(X));\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/events.cpp\n\n\n\n\nStates\n\n\n#include \nboost/msm-lite.hpp\n\n#include \niostream\n\n#include \ncassert\n\n\nnamespace msm = boost::msm::lite;\n\nstruct e1 {};\nstruct e2 {};\nstruct e3 {};\n\nstruct states {\n  auto configure() const noexcept {\n    using namespace msm;\n    state\nclass idle\n idle;\n    auto s2 = state\nclass s2\n{};\n\n    return make_transition_table(\n       *idle + event\ne1\n = \ns1\n_s\n      , \ns1\n_s + msm::on_entry / [] { std::cout \n \ns1 on entry\n \n std::endl; }\n      , \ns1\n_s + msm::on_exit / [] { std::cout \n \ns1 on exit\n \n std::endl; }\n      , \ns1\n_s + event\ne2\n = s2\n      , s2 + event\ne3\n = X\n    );\n  }\n};\n\nint main() {\n  msm::sm\nstates\n sm;\n  assert(sm.process_event(e1{}));\n  assert(sm.process_event(e2{}));\n  assert(sm.process_event(e3{}));\n  assert(sm.is(msm::X));\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/states.cpp\n\n\n\n\nActions Guards\n\n\n\n#include \nboost/msm-lite.hpp\n\n#include \ncassert\n\n#include \ntypeinfo\n\n#include \niostream\n\n\nnamespace msm = boost::msm::lite;\n\nstruct e1 {};\nstruct e2 {};\nstruct e3 {};\nstruct e4 {};\n\nauto guard1 = [] {\n  std::cout \n \nguard1\n \n std::endl;\n  return true;\n};\n\nauto guard2 = [](int i) {\n  assert(42 == i);\n  std::cout \n \nguard2\n \n std::endl;\n  return false;\n};\n\nauto action1 = [](auto e) { std::cout \n \naction1: \n \n typeid(e).name() \n std::endl; };\nstruct action2 {\n  void operator()(int i) {\n    assert(42 == i);\n    std::cout \n \naction2\n \n std::endl;\n  }\n};\n\nstruct actions_guards {\n  auto configure() const noexcept {\n    using namespace msm;\n    return make_transition_table(\n       *\nidle\n_s + event\ne1\n = \ns1\n_s\n      , \ns1\n_s + event\ne2\n [ guard1 ] / action1 = \ns2\n_s\n      , \ns2\n_s + event\ne3\n [ guard1 \n ![] { return false;} ] / (action1, action2{}) = \ns3\n_s\n      , \ns3\n_s + event\ne4\n [ !guard1 || guard2 ] / (action1, [] { std::cout \n \naction3\n \n std::endl; }) = \ns4\n_s\n      , \ns3\n_s + event\ne4\n [ guard1 ] / ([] { std::cout \n \naction4\n \n std::endl; }, [this] { action4(); }) = X\n    );\n  }\n\n  void action4() const { std::cout \n \naction4\n \n std::endl; }\n};\n\nint main() {\n  msm::sm\nactions_guards\n sm{42};\n  assert(sm.process_event(e1{}));\n  assert(sm.process_event(e2{}));\n  assert(sm.process_event(e3{}));\n  assert(sm.process_event(e4{}));\n  assert(sm.is(msm::X));\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/actions_guards.cpp\n\n\n\n\nTransitions\n\n\n#include \nboost/msm-lite.hpp\n\n#include \ncassert\n\n#include \niostream\n\n\nnamespace msm = boost::msm::lite;\n\nstruct e1 {};\nstruct e2 {};\nstruct e3 {};\n\nstruct transitions {\n  auto configure() const noexcept {\n    using namespace msm;\n    return make_transition_table(\n       *\nidle\n_s  / [] { std::cout \n \nanonymous transition\n \n std::endl; } = \ns1\n_s\n      , \ns1\n_s + event\ne1\n / [] { std::cout \n \ninternal transition\n \n std::endl; }\n      , \ns1\n_s + event\ne2\n / ([] { std::cout \n \nprocess internal event\n \n std::endl; }, process_event(e3{})) = X\n      , \ns1\n_s + event\ne3\n / [] { std::cout \n \nprocess event: e3\n; }\n    );\n  }\n};\n\nint main() {\n  msm::sm\ntransitions\n sm;\n  assert(sm.process_event(e1{}));\n  assert(sm.process_event(e2{}));\n  assert(sm.is(msm::X));\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/transitions.cpp\n\n\n\n\nOrthogonal Regions\n\n\n#include \nboost/msm-lite.hpp\n\n#include \ncassert\n\n\nnamespace msm = boost::msm::lite;\n\nstruct e1 {};\nstruct e2 {};\nstruct e3 {};\n\nstruct orthogonal_regions {\n  auto configure() const noexcept {\n    using namespace msm;\n    return make_transition_table(\n     *\nidle\n_s + event\ne1\n = \ns1\n_s\n    , \ns1\n_s + event\ne2\n = X\n\n    ,*\nidle2\n_s + event\ne2\n = \ns2\n_s\n    , \ns2\n_s + event\ne3\n = X\n    );\n  }\n};\n\nint main() {\n  msm::sm\northogonal_regions\n sm;\n  using namespace msm;\n  assert(sm.is(\nidle\n_s, \nidle2\n_s));\n  assert(sm.process_event(e1{}));\n  assert(sm.is(\ns1\n_s, \nidle2\n_s));\n  assert(sm.process_event(e2{}));\n  assert(sm.is(X, \ns2\n_s));\n  assert(sm.process_event(e3{}));\n  assert(sm.is(X, X));\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/orthogonal_regions.cpp\n\n\n\n\nComposite\n\n\n#include \nboost/msm-lite.hpp\n\n#include \niostream\n\n#include \ncassert\n\n\nnamespace msm = boost::msm::lite;\n\nstruct e1 {};\nstruct e2 {};\nstruct e3 {};\nstruct e4 {};\nstruct e5 {};\n\nstruct sub {\n  sub() {}\n  auto configure() const noexcept {\n    using namespace msm;\n      return make_transition_table(\n       *\nidle\n_s + event\ne3\n / [] { std::cout \n \nin sub sm\n \n std::endl; } = \ns1\n_s\n      , \ns1\n_s + event\ne4\n / [] { std::cout \n \nfinish sub sm\n \n std::endl; } = X\n      );\n  }\n};\n\nmsm::state\nmsm::sm\nsub\n sub_state;\n\nstruct composite {\n  composite() {}\n  auto configure() const noexcept {\n    using namespace msm;\n    return make_transition_table(\n     *\nidle\n_s + event\ne1\n = \ns1\n_s\n    , \ns1\n_s + event\ne2\n / [] { std::cout \n \nenter sub sm\n \n std::endl; } = sub_state\n    , sub_state + event\ne5\n / [] { std::cout \n \nexit sub sm\n \n std::endl; } = X\n    );\n  }\n};\n\nint main() {\n  sub sub_;\n  msm::sm\nsub\n sub_sm{sub_};\n  composite composite_;\n  msm::sm\ncomposite\n sm{composite_, sub_sm};\n\n  using namespace msm;\n  assert(sm.is(\nidle\n_s));\n  assert(sub_sm.is(\nidle\n_s));\n\n  assert(sm.process_event(e1{}));\n  assert(sm.is(\ns1\n_s));\n  assert(sub_sm.is(\nidle\n_s));\n\n  assert(sm.process_event(e2{}));  // enter sub sm\n  assert(sm.is(sub_state));\n  assert(sub_sm.is(\nidle\n_s));\n\n  assert(sm.process_event(e3{}));  // in sub sm\n  assert(sm.is(sub_state));\n  assert(sub_sm.is(\ns1\n_s));\n\n  assert(sm.process_event(e4{}));  // finish sub sm\n  assert(sm.is(sub_state));\n  assert(sub_sm.is(X));\n\n  assert(sm.process_event(e5{}));  // exit sub sm\n  assert(sm.is(X));\n  assert(sub_sm.is(X));\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/composite.cpp\n\n\n\n\nHistory\n\n\n#include \nboost/msm-lite.hpp\n\n#include \niostream\n\n#include \ncassert\n\n\nnamespace msm = boost::msm::lite;\n\nstruct sub {\n  auto configure() const noexcept {\n    using namespace msm;\n      return make_transition_table(\n        \ns1\n_s \n= \nidle\n_s(H) + \ne1\n_t / [] { std::cout \n \nin sub\n \n std::endl; }\n      , X      \n= \ns1\n_s      + \ne2\n_t / [] { std::cout \n \nin sub again\n \n std::endl; }\n      );\n  }\n};\n\nstruct history {\n  auto configure() const noexcept {\n    using namespace msm;\n    state\nsm\nsub\n sub_state;\n\n    return make_transition_table(\n      sub_state \n= *\nidle\n_s + \ne1\n_t / [] { std::cout \n \nenter sub\n \n std::endl; }\n    , \ns1\n_s    \n= sub_state + \ne3\n_t / [] { std::cout \n \nexit sub\n \n std::endl; }\n    , sub_state \n= \ns1\n_s    + \ne4\n_t / [] { std::cout \n \nenter sub again\n \n std::endl; }\n    );\n  }\n};\n\nint main() {\n  msm::sm\nhistory\n sm;\n  using namespace msm;\n  assert(sm.process_event(\ne1\n_t));\n  assert(sm.process_event(\ne1\n_t));  // enter sub\n  assert(sm.process_event(\ne3\n_t));  // exit sub\n  assert(sm.process_event(\ne4\n_t));  // enter sub\n  assert(sm.process_event(\ne2\n_t));  // in sub again (history)\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/history.cpp\n\n\n\n\nError handling\n\n\n#include \nboost/msm-lite.hpp\n\n#include \ncassert\n\n#include \niostream\n\n#include \nstdexcept\n\n\nnamespace msm = boost::msm::lite;\n\nstruct error_handling {\n  auto configure() const /*noexcept*/ {  // noexcept will call terminate\n    using namespace msm;\n    return make_transition_table(\n       *\nidle\n_s + \nevent1\n_t / [] { throw std::runtime_error{\nerror\n}; }\n      , \nidle\n_s + \nevent2\n_t / [] { throw 0; }\n\n      , *\nerror_handling\n_s + exception\nstd::runtime_error\n / [] { std::cout \n \nexception caught\n \n std::endl; }\n      ,  \nerror_handling\n_s + exception\n / [] { std::cout \n \ngeneric exception caught, terminate...\n \n std::endl; } = X\n    );\n  }\n};\n\nint main() {\n  using namespace msm;\n  sm\nerror_handling\n sm;\n  assert(sm.process_event(\nevent1\n_t));\n  assert(sm.is(\nidle\n_s, \nerror_handling\n_s));\n  assert(sm.process_event(\nevent2\n_t));\n  assert(sm.is(\nidle\n_s, X));\n  assert(sm.is(X));  // any region is terminated\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/error_handling.cpp\n\n\n\n\nLogging\n\n\n#include \ncstdio\n\n#include \ntypeinfo\n\n\ntemplate \nclass SM, class TEvent\n\nvoid log_process_event(const TEvent\n) {\n  printf(\n[%s][process_event] %s\\n\n, typeid(SM).name(), typeid(TEvent).name());\n}\n\ntemplate \nclass SM, class TGuard, class TEvent\n\nvoid log_guard(const TGuard\n, const TEvent\n, bool result) {\n  printf(\n[%s][guard] %s %s %s\\n\n, typeid(SM).name(), typeid(TGuard).name(), typeid(TEvent).name(),\n         (result ? \n[OK]\n : \n[Reject]\n));\n}\n\ntemplate \nclass SM, class TAction, class TEvent\n\nvoid log_action(const TAction\n, const TEvent\n) {\n  printf(\n[%s][action] %s %s\\n\n, typeid(SM).name(), typeid(TAction).name(), typeid(TEvent).name());\n}\n\ntemplate \nclass SM, class TSrcState, class TDstState\n\nvoid log_state_change(const TSrcState\n src, const TDstState\n dst) {\n  printf(\n[%s][transition] %s -\n %s\\n\n, typeid(SM).name(), src.c_str(), dst.c_str());\n}\n\n#define BOOST_MSM_LITE_LOG(T, SM, ...) log_##T\nSM\n(__VA_ARGS__)\n#include \nboost/msm-lite.hpp\n\n#include \ncassert\n\n#include \niostream\n\n\nnamespace msm = boost::msm::lite;\n\nstruct e1 {};\nstruct e2 {};\n\nstruct guard {\n  bool operator()() const { return true; }\n} guard;\n\nstruct action {\n  void operator()() {}\n} action;\n\nstruct logging {\n  auto configure() const noexcept {\n    using namespace msm;\n    return make_transition_table(\n       *\nidle\n_s + event\ne1\n [ guard \n guard ] / action = \ns1\n_s\n    );\n  }\n};\n\nint main() {\n  msm::sm\nlogging\n sm;\n  assert(sm.process_event(e1{}));\n  assert(!sm.process_event(e2{}));\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/logging.cpp\n\n\n\n\nTesting\n\n\n#include \nboost/msm-lite.hpp\n\n#include \ncassert\n\n\nnamespace msm = boost::msm::lite;\n\nstruct e1 {};\nstruct e2 {};\nstruct e3 {};\n\nstruct data {\n  int value = 0;\n};\n\nstruct fsm {\n  auto configure() const noexcept {\n    using namespace msm;\n\n    auto guard = [](data\n d) { return !d.value; };\n    auto action = [](data\n d) { d.value = 42; };\n\n    return make_transition_table(\n       *\nidle\n_s + event\ne1\n = \ns1\n_s\n      , \ns1\n_s + event\ne2\n = \ns2\n_s\n      , \ns2\n_s + event\ne3\n [guard] / action = X // transition under test\n    );\n  }\n};\n\nint main() {\n  using namespace msm;\n  data fake_data{0};\n  testing::sm\nfsm\n sm{fake_data};\n  sm.set_current_states(\ns2\n_s);\n  assert(sm.process_event(e3{}));\n  assert(sm.is(X));\n  assert(fake_data.value = 42);\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/testing.cpp\n\n\n\n\nRuntime Dispatcher\n\n\n#include \nboost/msm-lite.hpp\n\n#include \ncassert\n\n\nnamespace msm = boost::msm::lite;\n\nstruct runtime_event {\n  int id = 0;\n};\nstruct event1 {\n  static constexpr auto id = 1;\n  event1(const runtime_event \n) {}\n};\nstruct event2 {\n  static constexpr auto id = 2;\n};\n\nstruct dispatch_table {\n  auto configure() noexcept {\n    using namespace msm;\n    return make_transition_table(\n       *\nidle\n_s + event\nevent1\n = \ns1\n_s\n      , \ns1\n_s + event\nevent2\n = X\n    );\n  }\n};\n\nint main() {\n  msm::sm\ndispatch_table\n sm;\n\n  auto dispatch_event = msm::make_dispatch_table\nruntime_event, 1 /*min*/, 5 /*max*/\n(sm);\n\n  {\n    runtime_event event{1};\n    assert(dispatch_event(event, event.id));\n  }\n\n  {\n    runtime_event event{2};\n    assert(dispatch_event(event, event.id));\n  }\n\n  assert(sm.is(msm::X));\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/dispatch_table.cpp\n\n\n\n\neUML Emulation\n\n\n#include \nboost/msm-lite.hpp\n\n#include \ncassert\n\n\nnamespace msm = boost::msm::lite;\n\nstruct e1 {};\nstruct e2 {};\nstruct e3 {};\n\nauto event1 = msm::event\ne1\n;\nauto event2 = msm::event\ne2\n;\nauto event3 = msm::event\ne3\n;\n\nauto idle = msm::state\nclass idle\n{};\nauto s1 = msm::state\nclass s1\n{};\nauto s2 = msm::state\nclass s2\n{};\n\nstruct data {\n  void set(int value) noexcept { i = value; }\n  int get() const noexcept { return i; }\n  int i = 0;\n};\n\nstruct {\n  template \nclass FSM, class TEvent\n\n  bool operator()(msm::sm\nFSM\n, const TEvent\n, data\n d) const noexcept {\n    return d.get() == 42;\n  }\n} guard;\n\nstruct {\n  template \nclass FSM, class TEvent\n\n  void operator()(msm::sm\nFSM\n, const TEvent\n, data\n d) noexcept {\n    d.set(123);\n  }\n} action;\n\nclass euml_emulation {\n public:\n  auto configure() const noexcept {\n    using namespace msm;\n    return make_transition_table(\n      s1 \n= *idle + event1,\n      s2 \n= s1    + event2 [ guard ],\n      X  \n= s2    + event3 [ guard ] / action\n    );\n  }\n};\n\nint main() {\n  data d{42};\n  msm::sm\neuml_emulation\n sm{d};\n  assert(sm.is(idle));\n  assert(sm.process_event(e1{}));\n  assert(sm.is(s1));\n  assert(sm.process_event(e2{}));\n  assert(sm.is(s2));\n  assert(sm.process_event(e3{}));\n  assert(sm.is(msm::X));\n  assert(123 == d.get());\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/euml_emulation.cpp\n\n\n\n\nDependency Injection\n\n\n#if __has_include(\nboost/di.hpp\n)\n#include \nboost/msm-lite.hpp\n\n#include \nboost/di.hpp\n\n#include \ncassert\n\n#include \ntypeinfo\n\n#include \niostream\n\n\nnamespace msm = boost::msm::lite;\n\nstruct e1 {};\nstruct e2 {};\nstruct e3 {};\n\nauto guard = [](int i, double d) {\n  assert(42 == i);\n  assert(87.0 == d);\n  std::cout \n \nguard\n \n std::endl;\n  return true;\n};\n\nauto action = [](int i, auto e) {\n  assert(42 == i);\n  std::cout \n \naction: \n \n typeid(e).name() \n std::endl;\n};\n\nstruct example {\n  auto configure() const noexcept {\n    using namespace msm;\n    return make_transition_table(\n       *\nidle\n_s + event\ne1\n = \ns1\n_s\n      , \ns1\n_s + event\ne2\n [ guard ] / action = \ns2\n_s\n      , \ns2\n_s + event\ne3\n / [] { std::cout \n \nin place action\n \n std::endl; } = X\n    );\n  }\n};\n\nnamespace di = boost::di;\n\nclass controller {\n public:\n  explicit controller(msm::sm\nexample\n sm) : sm(sm) {}\n\n  void start() {\n    assert(sm.process_event(e1{}));\n    assert(sm.process_event(e2{}));\n    assert(sm.process_event(e3{}));\n    assert(sm.is(msm::X));\n  }\n\n private:\n  msm::sm\nexample\n sm;\n};\n\nint main() {\n  auto injector = di::make_injector(di::bind\n.to(42), di::bind\n.to(87.0));\n  injector.create\ncontroller\n().start();\n}\n#else\nint main() {}\n#endif\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/dependency_injection.cpp\n\n\n\n\nSDL2 Integration\n\n\n#include \nboost/msm-lite.hpp\n\n#include \ncassert\n\n#include \niostream\n\n\nnamespace msm = boost::msm::lite;\n\n#if __has_include(\nSDL2/SDL_events.h\n)\n#include \nSDL2/SDL_events.h\n\n#else\nenum { SDLK_SPACE = ' ' };\nenum SDL_EventType { SDL_FIRSTEVENT = 0, SDL_QUIT, SDL_KEYUP, SDL_MOUSEBUTTONUP, SDL_LASTEVENT };\nstruct SDL_KeyboardEvent {\n  SDL_EventType type;\n  struct {\n    int sym;\n  } keysym;\n};\nstruct SDL_MouseButtonEvent {\n  SDL_EventType type;\n  int button;\n};\nstruct SDL_QuitEvent {\n  SDL_EventType type;\n};\nunion SDL_Event {\n  SDL_EventType type;\n  SDL_KeyboardEvent key;\n  SDL_MouseButtonEvent button;\n  SDL_QuitEvent quit;\n};\n#endif\n\ntemplate \nSDL_EventType Id\n\nstruct sdl_event_impl {\n  static constexpr auto id = Id;\n  explicit sdl_event_impl(const SDL_Event\n data) noexcept : data(data) {}\n  SDL_Event data;\n};\n\ntemplate \nSDL_EventType Id\n\ndecltype(msm::event\nsdl_event_impl\nId\n) sdl_event{};\n\nauto is_key = [](auto key) { return [=](auto event) { return event.data.key.keysym.sym == key; }; };\n\nstruct sdl2 {\n  auto configure() const noexcept {\n    using namespace msm;\n    return make_transition_table(\n      //------------------------------------------------------------------------------//\n        \nwait_for_user_input\n_s \n= *\nidle\n_s\n          / [] { std::cout \n \ninitialization\n \n std::endl; }\n\n      , \nkey_pressed\n_s \n= \nwait_for_user_input\n_s + sdl_event\nSDL_KEYUP\n [ is_key(SDLK_SPACE) ]\n          / [] { std::cout \n \nspace pressed\n \n std::endl; }\n\n      , X \n= \nkey_pressed\n_s + sdl_event\nSDL_MOUSEBUTTONUP\n\n          / [] { std::cout \n \nmouse button pressed\n \n std::endl; }\n      //------------------------------------------------------------------------------//\n      , X \n= *\nwaiting_for_quit\n_s + sdl_event\nSDL_QUIT\n\n          / [] { std::cout \n \nquit\n \n std::endl; }\n      //------------------------------------------------------------------------------//\n    );\n  }\n};\n\nint main() {\n  msm::sm\nsdl2\n sm;\n  auto dispatch_event = msm::make_dispatch_table\nSDL_Event, SDL_FIRSTEVENT, SDL_LASTEVENT\n(sm);\n\n  SDL_Event event;\n\n  // while (SDL_PollEvent(\nevent)) {\n  //   dispatch_event(event, event.type)\n  // };\n\n  {\n    SDL_KeyboardEvent keyboard_event;\n    keyboard_event.type = SDL_KEYUP;\n    keyboard_event.keysym.sym = SDLK_SPACE;\n    event.key = keyboard_event;\n    assert(dispatch_event(event, event.type));\n  }\n\n  {\n    SDL_MouseButtonEvent mousebutton_event;\n    mousebutton_event.type = SDL_MOUSEBUTTONUP;\n    mousebutton_event.button = 1;\n    event.button = mousebutton_event;\n    assert(dispatch_event(event, event.type));\n  }\n\n  {\n    SDL_QuitEvent quit_event;\n    quit_event.type = SDL_QUIT;\n    event.quit = quit_event;\n    assert(dispatch_event(event, event.type));\n  }\n\n  assert(sm.is(msm::X, msm::X));\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/sdl2.cpp\n\n\n\n\nPlant UML Integration\n\n\n#include \nboost/msm-lite.hpp\n\n#include \ncassert\n\n#include \niostream\n\n#include \ntypeinfo\n\n#include \nstring\n\n\nnamespace msm = boost::msm::lite;\n\nstruct e1 {};\nstruct e2 {};\nstruct e3 {};\nstruct e4 {};\n\nstruct guard {\n  bool operator()() const { return true; }\n} guard;\n\nstruct action {\n  void operator()() {}\n} action;\n\nstruct plant_uml {\n  auto configure() const noexcept {\n    using namespace msm;\n    return make_transition_table(\n       *\nidle\n_s + event\ne1\n = \ns1\n_s\n      , \ns1\n_s + event\ne2\n [ guard ] / action = \ns2\n_s\n      , \ns2\n_s + event\ne3\n [ guard ] = \ns1\n_s\n      , \ns2\n_s + event\ne4\n / action = X\n    );\n  }\n};\n\ntemplate \nclass T\n\nvoid dump_transition() noexcept {\n  auto src_state = std::string{msm::state\ntypename T::src_state\n::c_str()};\n  auto dst_state = std::string{msm::state\ntypename T::dst_state\n::c_str()};\n  if (dst_state == \nX\n) {\n    dst_state = \n[*]\n;\n  }\n\n  if (T::initial) {\n    std::cout \n \n[*] --\n \n \n src_state \n std::endl;\n  }\n\n  std::cout \n src_state \n \n --\n \n \n dst_state;\n\n  const auto has_event = !msm::aux::is_same\ntypename T::event, msm::detail::anonymous\n::value;\n  const auto has_guard = !msm::aux::is_same\ntypename T::guard, msm::detail::always\n::value;\n  const auto has_action = !msm::aux::is_same\ntypename T::action, msm::detail::none\n::value;\n\n  if (has_event || has_guard || has_action) {\n    std::cout \n \n :\n;\n  }\n\n  if (has_event) {\n    std::cout \n \n \n \n typeid(typename T::event).name();\n  }\n\n  if (has_guard) {\n    std::cout \n \n [\n \n typeid(typename T::guard).name() \n \n]\n;\n  }\n\n  if (has_action) {\n    std::cout \n \n / \n \n typeid(typename T::action).name();\n  }\n\n  std::cout \n std::endl;\n}\n\ntemplate \ntemplate \nclass...\n class T, class... Ts\n\nvoid dump_transitions(const T\nTs...\n) noexcept {\n  int _[]{0, (dump_transition\nTs\n(), 0)...};\n  (void)_;\n}\n\ntemplate \nclass SM\n\nvoid dump(const SM\n) noexcept {\n  std::cout \n \n@startuml\n \n std::endl \n std::endl;\n  dump_transitions(typename SM::transitions{});\n  std::cout \n std::endl \n \n@enduml\n \n std::endl;\n}\n\nint main() {\n  msm::sm\nplant_uml\n sm;\n  dump(sm);\n}\n\n\n\n\n\n\nhttps://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/plant_uml.cpp", 
            "title": "Examples"
        }, 
        {
            "location": "/examples/index.html#hello-world", 
            "text": "#include  boost/msm-lite.hpp \n#include  cassert \n#include  iostream \n\nnamespace msm = boost::msm::lite;\n\nstruct e1 {};\nstruct e2 {};\nstruct e3 {};\n\nauto guard = [] {\n  std::cout    guard    std::endl;\n  return true;\n};\n\nauto action = [] { std::cout    action    std::endl; };\n\nstruct hello_world {\n  auto configure() const noexcept {\n    using namespace msm;\n    return make_transition_table(\n       * idle _s + event e1  =  s1 _s\n      ,  s1 _s + event e2  [ guard ] / action =  s2 _s\n      ,  s2 _s + event e3  / [] { std::cout    in place action    std::endl; } = X\n    );\n  }\n};\n\nint main() {\n  msm::sm hello_world  sm;\n  using namespace msm;\n  assert(sm.is( idle _s));\n  assert(sm.process_event(e1{}));\n  assert(sm.is( s1 _s));\n  assert(sm.process_event(e2{}));\n  assert(sm.is( s2 _s));\n  assert(sm.process_event(e3{}));\n  assert(sm.is(X));\n}   https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/hello_world.cpp", 
            "title": "Hello World"
        }, 
        {
            "location": "/examples/index.html#events", 
            "text": "#include  boost/msm-lite.hpp \n#include  cassert \n\nnamespace msm = boost::msm::lite;\n\nstruct e1 {};\nstruct e2 {\n  bool value = true;\n};\nauto event2 = msm::event e2 ;\n\nstruct events {\n  auto configure() const noexcept {\n    using namespace msm;\n    auto guard = [](const e2  e) { return e.value; };\n\n    return make_transition_table(\n       * idle _s + event e1  =  s1 _s\n      ,  s1 _s + event2 [guard] =  s2 _s\n      ,  s2 _s +  e3 _t =  s3 _s\n      ,  s3 _s + event int  / [] (int i) { assert(42 == i); } = X\n    );\n  }\n};\n\nint main() {\n  msm::sm events  sm;\n  using namespace msm;\n  assert(sm.process_event(e1{}));\n  assert(sm.process_event(e2{}));\n  assert(sm.process_event( e3 _t));\n  assert(sm.process_event(42));\n  assert(sm.is(X));\n}   https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/events.cpp", 
            "title": "Events"
        }, 
        {
            "location": "/examples/index.html#states", 
            "text": "#include  boost/msm-lite.hpp \n#include  iostream \n#include  cassert \n\nnamespace msm = boost::msm::lite;\n\nstruct e1 {};\nstruct e2 {};\nstruct e3 {};\n\nstruct states {\n  auto configure() const noexcept {\n    using namespace msm;\n    state class idle  idle;\n    auto s2 = state class s2 {};\n\n    return make_transition_table(\n       *idle + event e1  =  s1 _s\n      ,  s1 _s + msm::on_entry / [] { std::cout    s1 on entry    std::endl; }\n      ,  s1 _s + msm::on_exit / [] { std::cout    s1 on exit    std::endl; }\n      ,  s1 _s + event e2  = s2\n      , s2 + event e3  = X\n    );\n  }\n};\n\nint main() {\n  msm::sm states  sm;\n  assert(sm.process_event(e1{}));\n  assert(sm.process_event(e2{}));\n  assert(sm.process_event(e3{}));\n  assert(sm.is(msm::X));\n}   https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/states.cpp", 
            "title": "States"
        }, 
        {
            "location": "/examples/index.html#actions-guards", 
            "text": "#include  boost/msm-lite.hpp \n#include  cassert \n#include  typeinfo \n#include  iostream \n\nnamespace msm = boost::msm::lite;\n\nstruct e1 {};\nstruct e2 {};\nstruct e3 {};\nstruct e4 {};\n\nauto guard1 = [] {\n  std::cout    guard1    std::endl;\n  return true;\n};\n\nauto guard2 = [](int i) {\n  assert(42 == i);\n  std::cout    guard2    std::endl;\n  return false;\n};\n\nauto action1 = [](auto e) { std::cout    action1:     typeid(e).name()   std::endl; };\nstruct action2 {\n  void operator()(int i) {\n    assert(42 == i);\n    std::cout    action2    std::endl;\n  }\n};\n\nstruct actions_guards {\n  auto configure() const noexcept {\n    using namespace msm;\n    return make_transition_table(\n       * idle _s + event e1  =  s1 _s\n      ,  s1 _s + event e2  [ guard1 ] / action1 =  s2 _s\n      ,  s2 _s + event e3  [ guard1   ![] { return false;} ] / (action1, action2{}) =  s3 _s\n      ,  s3 _s + event e4  [ !guard1 || guard2 ] / (action1, [] { std::cout    action3    std::endl; }) =  s4 _s\n      ,  s3 _s + event e4  [ guard1 ] / ([] { std::cout    action4    std::endl; }, [this] { action4(); }) = X\n    );\n  }\n\n  void action4() const { std::cout    action4    std::endl; }\n};\n\nint main() {\n  msm::sm actions_guards  sm{42};\n  assert(sm.process_event(e1{}));\n  assert(sm.process_event(e2{}));\n  assert(sm.process_event(e3{}));\n  assert(sm.process_event(e4{}));\n  assert(sm.is(msm::X));\n}   https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/actions_guards.cpp", 
            "title": "Actions Guards"
        }, 
        {
            "location": "/examples/index.html#transitions", 
            "text": "#include  boost/msm-lite.hpp \n#include  cassert \n#include  iostream \n\nnamespace msm = boost::msm::lite;\n\nstruct e1 {};\nstruct e2 {};\nstruct e3 {};\n\nstruct transitions {\n  auto configure() const noexcept {\n    using namespace msm;\n    return make_transition_table(\n       * idle _s  / [] { std::cout    anonymous transition    std::endl; } =  s1 _s\n      ,  s1 _s + event e1  / [] { std::cout    internal transition    std::endl; }\n      ,  s1 _s + event e2  / ([] { std::cout    process internal event    std::endl; }, process_event(e3{})) = X\n      ,  s1 _s + event e3  / [] { std::cout    process event: e3 ; }\n    );\n  }\n};\n\nint main() {\n  msm::sm transitions  sm;\n  assert(sm.process_event(e1{}));\n  assert(sm.process_event(e2{}));\n  assert(sm.is(msm::X));\n}   https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/transitions.cpp", 
            "title": "Transitions"
        }, 
        {
            "location": "/examples/index.html#orthogonal-regions", 
            "text": "#include  boost/msm-lite.hpp \n#include  cassert \n\nnamespace msm = boost::msm::lite;\n\nstruct e1 {};\nstruct e2 {};\nstruct e3 {};\n\nstruct orthogonal_regions {\n  auto configure() const noexcept {\n    using namespace msm;\n    return make_transition_table(\n     * idle _s + event e1  =  s1 _s\n    ,  s1 _s + event e2  = X\n\n    ,* idle2 _s + event e2  =  s2 _s\n    ,  s2 _s + event e3  = X\n    );\n  }\n};\n\nint main() {\n  msm::sm orthogonal_regions  sm;\n  using namespace msm;\n  assert(sm.is( idle _s,  idle2 _s));\n  assert(sm.process_event(e1{}));\n  assert(sm.is( s1 _s,  idle2 _s));\n  assert(sm.process_event(e2{}));\n  assert(sm.is(X,  s2 _s));\n  assert(sm.process_event(e3{}));\n  assert(sm.is(X, X));\n}   https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/orthogonal_regions.cpp", 
            "title": "Orthogonal Regions"
        }, 
        {
            "location": "/examples/index.html#composite", 
            "text": "#include  boost/msm-lite.hpp \n#include  iostream \n#include  cassert \n\nnamespace msm = boost::msm::lite;\n\nstruct e1 {};\nstruct e2 {};\nstruct e3 {};\nstruct e4 {};\nstruct e5 {};\n\nstruct sub {\n  sub() {}\n  auto configure() const noexcept {\n    using namespace msm;\n      return make_transition_table(\n       * idle _s + event e3  / [] { std::cout    in sub sm    std::endl; } =  s1 _s\n      ,  s1 _s + event e4  / [] { std::cout    finish sub sm    std::endl; } = X\n      );\n  }\n};\n\nmsm::state msm::sm sub  sub_state;\n\nstruct composite {\n  composite() {}\n  auto configure() const noexcept {\n    using namespace msm;\n    return make_transition_table(\n     * idle _s + event e1  =  s1 _s\n    ,  s1 _s + event e2  / [] { std::cout    enter sub sm    std::endl; } = sub_state\n    , sub_state + event e5  / [] { std::cout    exit sub sm    std::endl; } = X\n    );\n  }\n};\n\nint main() {\n  sub sub_;\n  msm::sm sub  sub_sm{sub_};\n  composite composite_;\n  msm::sm composite  sm{composite_, sub_sm};\n\n  using namespace msm;\n  assert(sm.is( idle _s));\n  assert(sub_sm.is( idle _s));\n\n  assert(sm.process_event(e1{}));\n  assert(sm.is( s1 _s));\n  assert(sub_sm.is( idle _s));\n\n  assert(sm.process_event(e2{}));  // enter sub sm\n  assert(sm.is(sub_state));\n  assert(sub_sm.is( idle _s));\n\n  assert(sm.process_event(e3{}));  // in sub sm\n  assert(sm.is(sub_state));\n  assert(sub_sm.is( s1 _s));\n\n  assert(sm.process_event(e4{}));  // finish sub sm\n  assert(sm.is(sub_state));\n  assert(sub_sm.is(X));\n\n  assert(sm.process_event(e5{}));  // exit sub sm\n  assert(sm.is(X));\n  assert(sub_sm.is(X));\n}   https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/composite.cpp", 
            "title": "Composite"
        }, 
        {
            "location": "/examples/index.html#history", 
            "text": "#include  boost/msm-lite.hpp \n#include  iostream \n#include  cassert \n\nnamespace msm = boost::msm::lite;\n\nstruct sub {\n  auto configure() const noexcept {\n    using namespace msm;\n      return make_transition_table(\n         s1 _s  =  idle _s(H) +  e1 _t / [] { std::cout    in sub    std::endl; }\n      , X       =  s1 _s      +  e2 _t / [] { std::cout    in sub again    std::endl; }\n      );\n  }\n};\n\nstruct history {\n  auto configure() const noexcept {\n    using namespace msm;\n    state sm sub  sub_state;\n\n    return make_transition_table(\n      sub_state  = * idle _s +  e1 _t / [] { std::cout    enter sub    std::endl; }\n    ,  s1 _s     = sub_state +  e3 _t / [] { std::cout    exit sub    std::endl; }\n    , sub_state  =  s1 _s    +  e4 _t / [] { std::cout    enter sub again    std::endl; }\n    );\n  }\n};\n\nint main() {\n  msm::sm history  sm;\n  using namespace msm;\n  assert(sm.process_event( e1 _t));\n  assert(sm.process_event( e1 _t));  // enter sub\n  assert(sm.process_event( e3 _t));  // exit sub\n  assert(sm.process_event( e4 _t));  // enter sub\n  assert(sm.process_event( e2 _t));  // in sub again (history)\n}   https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/history.cpp", 
            "title": "History"
        }, 
        {
            "location": "/examples/index.html#error-handling", 
            "text": "#include  boost/msm-lite.hpp \n#include  cassert \n#include  iostream \n#include  stdexcept \n\nnamespace msm = boost::msm::lite;\n\nstruct error_handling {\n  auto configure() const /*noexcept*/ {  // noexcept will call terminate\n    using namespace msm;\n    return make_transition_table(\n       * idle _s +  event1 _t / [] { throw std::runtime_error{ error }; }\n      ,  idle _s +  event2 _t / [] { throw 0; }\n\n      , * error_handling _s + exception std::runtime_error  / [] { std::cout    exception caught    std::endl; }\n      ,   error_handling _s + exception  / [] { std::cout    generic exception caught, terminate...    std::endl; } = X\n    );\n  }\n};\n\nint main() {\n  using namespace msm;\n  sm error_handling  sm;\n  assert(sm.process_event( event1 _t));\n  assert(sm.is( idle _s,  error_handling _s));\n  assert(sm.process_event( event2 _t));\n  assert(sm.is( idle _s, X));\n  assert(sm.is(X));  // any region is terminated\n}   https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/error_handling.cpp", 
            "title": "Error handling"
        }, 
        {
            "location": "/examples/index.html#logging", 
            "text": "#include  cstdio \n#include  typeinfo \n\ntemplate  class SM, class TEvent \nvoid log_process_event(const TEvent ) {\n  printf( [%s][process_event] %s\\n , typeid(SM).name(), typeid(TEvent).name());\n}\n\ntemplate  class SM, class TGuard, class TEvent \nvoid log_guard(const TGuard , const TEvent , bool result) {\n  printf( [%s][guard] %s %s %s\\n , typeid(SM).name(), typeid(TGuard).name(), typeid(TEvent).name(),\n         (result ?  [OK]  :  [Reject] ));\n}\n\ntemplate  class SM, class TAction, class TEvent \nvoid log_action(const TAction , const TEvent ) {\n  printf( [%s][action] %s %s\\n , typeid(SM).name(), typeid(TAction).name(), typeid(TEvent).name());\n}\n\ntemplate  class SM, class TSrcState, class TDstState \nvoid log_state_change(const TSrcState  src, const TDstState  dst) {\n  printf( [%s][transition] %s -  %s\\n , typeid(SM).name(), src.c_str(), dst.c_str());\n}\n\n#define BOOST_MSM_LITE_LOG(T, SM, ...) log_##T SM (__VA_ARGS__)\n#include  boost/msm-lite.hpp \n#include  cassert \n#include  iostream \n\nnamespace msm = boost::msm::lite;\n\nstruct e1 {};\nstruct e2 {};\n\nstruct guard {\n  bool operator()() const { return true; }\n} guard;\n\nstruct action {\n  void operator()() {}\n} action;\n\nstruct logging {\n  auto configure() const noexcept {\n    using namespace msm;\n    return make_transition_table(\n       * idle _s + event e1  [ guard   guard ] / action =  s1 _s\n    );\n  }\n};\n\nint main() {\n  msm::sm logging  sm;\n  assert(sm.process_event(e1{}));\n  assert(!sm.process_event(e2{}));\n}   https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/logging.cpp", 
            "title": "Logging"
        }, 
        {
            "location": "/examples/index.html#testing", 
            "text": "#include  boost/msm-lite.hpp \n#include  cassert \n\nnamespace msm = boost::msm::lite;\n\nstruct e1 {};\nstruct e2 {};\nstruct e3 {};\n\nstruct data {\n  int value = 0;\n};\n\nstruct fsm {\n  auto configure() const noexcept {\n    using namespace msm;\n\n    auto guard = [](data  d) { return !d.value; };\n    auto action = [](data  d) { d.value = 42; };\n\n    return make_transition_table(\n       * idle _s + event e1  =  s1 _s\n      ,  s1 _s + event e2  =  s2 _s\n      ,  s2 _s + event e3  [guard] / action = X // transition under test\n    );\n  }\n};\n\nint main() {\n  using namespace msm;\n  data fake_data{0};\n  testing::sm fsm  sm{fake_data};\n  sm.set_current_states( s2 _s);\n  assert(sm.process_event(e3{}));\n  assert(sm.is(X));\n  assert(fake_data.value = 42);\n}   https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/testing.cpp", 
            "title": "Testing"
        }, 
        {
            "location": "/examples/index.html#runtime-dispatcher", 
            "text": "#include  boost/msm-lite.hpp \n#include  cassert \n\nnamespace msm = boost::msm::lite;\n\nstruct runtime_event {\n  int id = 0;\n};\nstruct event1 {\n  static constexpr auto id = 1;\n  event1(const runtime_event  ) {}\n};\nstruct event2 {\n  static constexpr auto id = 2;\n};\n\nstruct dispatch_table {\n  auto configure() noexcept {\n    using namespace msm;\n    return make_transition_table(\n       * idle _s + event event1  =  s1 _s\n      ,  s1 _s + event event2  = X\n    );\n  }\n};\n\nint main() {\n  msm::sm dispatch_table  sm;\n\n  auto dispatch_event = msm::make_dispatch_table runtime_event, 1 /*min*/, 5 /*max*/ (sm);\n\n  {\n    runtime_event event{1};\n    assert(dispatch_event(event, event.id));\n  }\n\n  {\n    runtime_event event{2};\n    assert(dispatch_event(event, event.id));\n  }\n\n  assert(sm.is(msm::X));\n}   https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/dispatch_table.cpp", 
            "title": "Runtime Dispatcher"
        }, 
        {
            "location": "/examples/index.html#euml-emulation", 
            "text": "#include  boost/msm-lite.hpp \n#include  cassert \n\nnamespace msm = boost::msm::lite;\n\nstruct e1 {};\nstruct e2 {};\nstruct e3 {};\n\nauto event1 = msm::event e1 ;\nauto event2 = msm::event e2 ;\nauto event3 = msm::event e3 ;\n\nauto idle = msm::state class idle {};\nauto s1 = msm::state class s1 {};\nauto s2 = msm::state class s2 {};\n\nstruct data {\n  void set(int value) noexcept { i = value; }\n  int get() const noexcept { return i; }\n  int i = 0;\n};\n\nstruct {\n  template  class FSM, class TEvent \n  bool operator()(msm::sm FSM , const TEvent , data  d) const noexcept {\n    return d.get() == 42;\n  }\n} guard;\n\nstruct {\n  template  class FSM, class TEvent \n  void operator()(msm::sm FSM , const TEvent , data  d) noexcept {\n    d.set(123);\n  }\n} action;\n\nclass euml_emulation {\n public:\n  auto configure() const noexcept {\n    using namespace msm;\n    return make_transition_table(\n      s1  = *idle + event1,\n      s2  = s1    + event2 [ guard ],\n      X   = s2    + event3 [ guard ] / action\n    );\n  }\n};\n\nint main() {\n  data d{42};\n  msm::sm euml_emulation  sm{d};\n  assert(sm.is(idle));\n  assert(sm.process_event(e1{}));\n  assert(sm.is(s1));\n  assert(sm.process_event(e2{}));\n  assert(sm.is(s2));\n  assert(sm.process_event(e3{}));\n  assert(sm.is(msm::X));\n  assert(123 == d.get());\n}   https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/euml_emulation.cpp", 
            "title": "eUML Emulation"
        }, 
        {
            "location": "/examples/index.html#dependency-injection", 
            "text": "#if __has_include( boost/di.hpp )\n#include  boost/msm-lite.hpp \n#include  boost/di.hpp \n#include  cassert \n#include  typeinfo \n#include  iostream \n\nnamespace msm = boost::msm::lite;\n\nstruct e1 {};\nstruct e2 {};\nstruct e3 {};\n\nauto guard = [](int i, double d) {\n  assert(42 == i);\n  assert(87.0 == d);\n  std::cout    guard    std::endl;\n  return true;\n};\n\nauto action = [](int i, auto e) {\n  assert(42 == i);\n  std::cout    action:     typeid(e).name()   std::endl;\n};\n\nstruct example {\n  auto configure() const noexcept {\n    using namespace msm;\n    return make_transition_table(\n       * idle _s + event e1  =  s1 _s\n      ,  s1 _s + event e2  [ guard ] / action =  s2 _s\n      ,  s2 _s + event e3  / [] { std::cout    in place action    std::endl; } = X\n    );\n  }\n};\n\nnamespace di = boost::di;\n\nclass controller {\n public:\n  explicit controller(msm::sm example  sm) : sm(sm) {}\n\n  void start() {\n    assert(sm.process_event(e1{}));\n    assert(sm.process_event(e2{}));\n    assert(sm.process_event(e3{}));\n    assert(sm.is(msm::X));\n  }\n\n private:\n  msm::sm example  sm;\n};\n\nint main() {\n  auto injector = di::make_injector(di::bind .to(42), di::bind .to(87.0));\n  injector.create controller ().start();\n}\n#else\nint main() {}\n#endif   https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/dependency_injection.cpp", 
            "title": "Dependency Injection"
        }, 
        {
            "location": "/examples/index.html#sdl2-integration", 
            "text": "#include  boost/msm-lite.hpp \n#include  cassert \n#include  iostream \n\nnamespace msm = boost::msm::lite;\n\n#if __has_include( SDL2/SDL_events.h )\n#include  SDL2/SDL_events.h \n#else\nenum { SDLK_SPACE = ' ' };\nenum SDL_EventType { SDL_FIRSTEVENT = 0, SDL_QUIT, SDL_KEYUP, SDL_MOUSEBUTTONUP, SDL_LASTEVENT };\nstruct SDL_KeyboardEvent {\n  SDL_EventType type;\n  struct {\n    int sym;\n  } keysym;\n};\nstruct SDL_MouseButtonEvent {\n  SDL_EventType type;\n  int button;\n};\nstruct SDL_QuitEvent {\n  SDL_EventType type;\n};\nunion SDL_Event {\n  SDL_EventType type;\n  SDL_KeyboardEvent key;\n  SDL_MouseButtonEvent button;\n  SDL_QuitEvent quit;\n};\n#endif\n\ntemplate  SDL_EventType Id \nstruct sdl_event_impl {\n  static constexpr auto id = Id;\n  explicit sdl_event_impl(const SDL_Event  data) noexcept : data(data) {}\n  SDL_Event data;\n};\n\ntemplate  SDL_EventType Id \ndecltype(msm::event sdl_event_impl Id ) sdl_event{};\n\nauto is_key = [](auto key) { return [=](auto event) { return event.data.key.keysym.sym == key; }; };\n\nstruct sdl2 {\n  auto configure() const noexcept {\n    using namespace msm;\n    return make_transition_table(\n      //------------------------------------------------------------------------------//\n         wait_for_user_input _s  = * idle _s\n          / [] { std::cout    initialization    std::endl; }\n\n      ,  key_pressed _s  =  wait_for_user_input _s + sdl_event SDL_KEYUP  [ is_key(SDLK_SPACE) ]\n          / [] { std::cout    space pressed    std::endl; }\n\n      , X  =  key_pressed _s + sdl_event SDL_MOUSEBUTTONUP \n          / [] { std::cout    mouse button pressed    std::endl; }\n      //------------------------------------------------------------------------------//\n      , X  = * waiting_for_quit _s + sdl_event SDL_QUIT \n          / [] { std::cout    quit    std::endl; }\n      //------------------------------------------------------------------------------//\n    );\n  }\n};\n\nint main() {\n  msm::sm sdl2  sm;\n  auto dispatch_event = msm::make_dispatch_table SDL_Event, SDL_FIRSTEVENT, SDL_LASTEVENT (sm);\n\n  SDL_Event event;\n\n  // while (SDL_PollEvent( event)) {\n  //   dispatch_event(event, event.type)\n  // };\n\n  {\n    SDL_KeyboardEvent keyboard_event;\n    keyboard_event.type = SDL_KEYUP;\n    keyboard_event.keysym.sym = SDLK_SPACE;\n    event.key = keyboard_event;\n    assert(dispatch_event(event, event.type));\n  }\n\n  {\n    SDL_MouseButtonEvent mousebutton_event;\n    mousebutton_event.type = SDL_MOUSEBUTTONUP;\n    mousebutton_event.button = 1;\n    event.button = mousebutton_event;\n    assert(dispatch_event(event, event.type));\n  }\n\n  {\n    SDL_QuitEvent quit_event;\n    quit_event.type = SDL_QUIT;\n    event.quit = quit_event;\n    assert(dispatch_event(event, event.type));\n  }\n\n  assert(sm.is(msm::X, msm::X));\n}   https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/sdl2.cpp", 
            "title": "SDL2 Integration"
        }, 
        {
            "location": "/examples/index.html#plant-uml-integration", 
            "text": "#include  boost/msm-lite.hpp \n#include  cassert \n#include  iostream \n#include  typeinfo \n#include  string \n\nnamespace msm = boost::msm::lite;\n\nstruct e1 {};\nstruct e2 {};\nstruct e3 {};\nstruct e4 {};\n\nstruct guard {\n  bool operator()() const { return true; }\n} guard;\n\nstruct action {\n  void operator()() {}\n} action;\n\nstruct plant_uml {\n  auto configure() const noexcept {\n    using namespace msm;\n    return make_transition_table(\n       * idle _s + event e1  =  s1 _s\n      ,  s1 _s + event e2  [ guard ] / action =  s2 _s\n      ,  s2 _s + event e3  [ guard ] =  s1 _s\n      ,  s2 _s + event e4  / action = X\n    );\n  }\n};\n\ntemplate  class T \nvoid dump_transition() noexcept {\n  auto src_state = std::string{msm::state typename T::src_state ::c_str()};\n  auto dst_state = std::string{msm::state typename T::dst_state ::c_str()};\n  if (dst_state ==  X ) {\n    dst_state =  [*] ;\n  }\n\n  if (T::initial) {\n    std::cout    [*] --      src_state   std::endl;\n  }\n\n  std::cout   src_state     --      dst_state;\n\n  const auto has_event = !msm::aux::is_same typename T::event, msm::detail::anonymous ::value;\n  const auto has_guard = !msm::aux::is_same typename T::guard, msm::detail::always ::value;\n  const auto has_action = !msm::aux::is_same typename T::action, msm::detail::none ::value;\n\n  if (has_event || has_guard || has_action) {\n    std::cout     : ;\n  }\n\n  if (has_event) {\n    std::cout         typeid(typename T::event).name();\n  }\n\n  if (has_guard) {\n    std::cout     [    typeid(typename T::guard).name()    ] ;\n  }\n\n  if (has_action) {\n    std::cout     /     typeid(typename T::action).name();\n  }\n\n  std::cout   std::endl;\n}\n\ntemplate  template  class...  class T, class... Ts \nvoid dump_transitions(const T Ts... ) noexcept {\n  int _[]{0, (dump_transition Ts (), 0)...};\n  (void)_;\n}\n\ntemplate  class SM \nvoid dump(const SM ) noexcept {\n  std::cout    @startuml    std::endl   std::endl;\n  dump_transitions(typename SM::transitions{});\n  std::cout   std::endl    @enduml    std::endl;\n}\n\nint main() {\n  msm::sm plant_uml  sm;\n  dump(sm);\n}   https://raw.githubusercontent.com/boost-experimental/msm-lite/master/example/plant_uml.cpp", 
            "title": "Plant UML Integration"
        }, 
        {
            "location": "/CHANGELOG/index.html", 
            "text": "1.0.1\n - 2016-05-06\n\n\n\n\nAdditions\n\n\nSupport for GCC-6.1\n\n\n\n\n\n\n\n\n1.0.0\n - 2016-01-28\n\n\n\n\nInitial version", 
            "title": "CHANGELOG"
        }, 
        {
            "location": "/CHANGELOG/index.html#101-2016-05-06", 
            "text": "Additions  Support for GCC-6.1", 
            "title": "1.0.1 - 2016-05-06"
        }, 
        {
            "location": "/CHANGELOG/index.html#100-2016-01-28", 
            "text": "Initial version", 
            "title": "1.0.0 - 2016-01-28"
        }, 
        {
            "location": "/TODO/index.html", 
            "text": "https://waffle.io/boost-experimental/msm-lite", 
            "title": "TODO"
        }
    ]
}